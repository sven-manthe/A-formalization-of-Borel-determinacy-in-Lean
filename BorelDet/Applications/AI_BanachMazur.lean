/-
This file was generated by AI and not checked carefully for correctness by the authors.
The generated code is due to Zar Goertzel (see
  https://github.com/sven-manthe/A-formalization-of-Borel-determinacy-in-Lean/pull/1)
-/

import BorelDet.Applications.Choquet
import Mathlib.Topology.MetricSpace.Bounded
import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Topology.Bornology.Basic
import Mathlib.Order.Zorn
import Mathlib.Topology.Baire.Lemmas

open GaleStewartGame
open Descriptive
open Choquet

variable {X : Type*} (V : Set (Set X)) (PO : Set (Set X))

namespace BanachMazur

open Topology

variable {X : Type*} [TopologicalSpace X]

/-- The usual Banach‚ÄìMazur game data: a family `W` of nonempty open sets that refines every nonempty
open set. -/
structure Family (X : Type*) [TopologicalSpace X] where
  W : Set (Set X)
  isOpen_mem : ‚àÄ {U}, U ‚àà W ‚Üí IsOpen U
  nonempty_mem : ‚àÄ {U}, U ‚àà W ‚Üí U.Nonempty
  nonempty : ‚àÉ U, U ‚àà W
  refine_open : ‚àÄ {U}, IsOpen U ‚Üí U.Nonempty ‚Üí ‚àÉ V, V ‚àà W ‚àß V ‚äÜ U

namespace Family

variable (F : Family X)

noncomputable def default : F.W :=
  ‚ü®F.nonempty.choose, F.nonempty.choose_spec‚ü©

noncomputable def chooseIn (U : Set X) (hUo : IsOpen U) (hUne : U.Nonempty) : F.W :=
  ‚ü®(F.refine_open (U := U) hUo hUne).choose, (F.refine_open (U := U) hUo hUne).choose_spec.1‚ü©

lemma chooseIn_subset (U : Set X) (hUo : IsOpen U) (hUne : U.Nonempty) :
    (F.chooseIn U hUo hUne : Set X) ‚äÜ U :=
  (F.refine_open (U := U) hUo hUne).choose_spec.2

end Family

/-- Player I wins iff `A` meets the intersection of the played sets. -/
def payoffHits (A : Set X) : Set (Set X) := {s | (A ‚à© s).Nonempty}

def game (F : Family X) (A : Set X) : Game F.W :=
  interGame (X := X) (V := F.W) (PO := payoffHits (X := X) A)

section Meagre

variable (F : Family X) {A : Set X}

noncomputable def preAvoidMeagre (hA : IsMeagre A) : PreStrategy (chainTree F.W) Player.one := by
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  -- On Player II positions, allow all moves staying inside the current open set and outside
  -- `closure (N k)`, where `k` is the move number of Player II (computed from the length).
  refine fun x hp => by
    have hxne : x.val ‚â† [] := by
      intro h0
      have : x.val.length % 2 = 0 := by simp [h0]
      -- Contradiction: Player II moves on odd positions.
      have : x.val.length % 2 = 1 := by simpa [IsPosition, Player.toNat] using hp
      omega
    let Uel : F.W := x.val.getLast hxne
    let U : Set X := (Uel : Set X)
    let k : ‚Ñï := x.val.length / 2
    exact {a | (a.val : Set X) ‚äÜ U ‚à© (closure (N k : Set X))·∂ú}

noncomputable def quasiAvoidMeagre (hA : IsMeagre A) : QuasiStrategy (chainTree F.W) Player.one := by
  let P : PreStrategy (chainTree F.W) Player.one := preAvoidMeagre (F := F) (A := A) hA
  refine ‚ü®P, ?_‚ü©
  intro x hp
  -- Produce one legal move using the basis property inside `U ‚à© (closure (N k))·∂ú`.
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  have hxne : x.val ‚â† [] := by
    intro h0
    have : x.val.length % 2 = 0 := by simp [h0]
    have : x.val.length % 2 = 1 := by simpa [IsPosition, Player.toNat] using hp
    omega
  let Uel : F.W := x.val.getLast hxne
  let U : Set X := (Uel : Set X)
  have hUo : IsOpen U := F.isOpen_mem (U := U) Uel.property
  have hUne : U.Nonempty := F.nonempty_mem (U := U) Uel.property
  let k : ‚Ñï := x.val.length / 2
  have hDense : Dense (closure (N k : Set X))·∂ú := by
    have hNW : IsNowhereDense (closure (N k : Set X)) := (N k).2.closure
    have : IsOpen (closure (N k : Set X))·∂ú ‚àß Dense (closure (N k : Set X))·∂ú := by
      simpa using (isClosed_isNowhereDense_iff_compl (s := closure (N k : Set X))).1
        ‚ü®isClosed_closure, hNW‚ü©
    exact this.2
  have hU'ne : (U ‚à© (closure (N k : Set X))·∂ú).Nonempty :=
    by simpa [Set.inter_comm] using hDense.inter_open_nonempty U hUo hUne
  -- Choose a move in `F.W` refining that open set.
  let Vset : Set X := (F.refine_open (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose
  have hVmem : Vset ‚àà F.W := (F.refine_open (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose_spec.1
  have hVsub : Vset ‚äÜ U ‚à© (closure (N k : Set X))·∂ú := (F.refine_open (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose_spec.2
  let V : F.W := ‚ü®Vset, hVmem‚ü©
  -- Show it is a legal extension in `chainTree`.
  have hVsubU : (V : Set X) ‚äÜ U := fun z hz => (hVsub hz).1
  have hExt : x.val ++ [V] ‚àà chainTree F.W := by
    rw [concat_mem_chainTree (V := F.W)]
    refine ‚ü®x.prop, fun _ => ?_‚ü©
    exact hVsubU
  refine ‚ü®‚ü®V, hExt‚ü©, ?_‚ü©
  -- Membership in the allowed set.
  exact hVsub

theorem existsWinning_one_of_isMeagre (A : Set X) (hA : IsMeagre A) :
    (game (X := X) F A).ExistsWinning Player.one := by
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  have hAeq : A = ‚ãÉ n, (N n : Set X) :=
    Classical.choose_spec (hA.eq_countable_union_isNowhereDense)
  -- It is easier to construct a winning *quasistrategy* and then choose a deterministic strategy.
  -- `ExistsWinning` is equivalent to the existence of a winning quasistrategy.
  refine (GaleStewartGame.Game.existsWinning_iff_quasi (G := game (X := X) F A) (p := Player.one)).2 ?_
  refine ‚ü®quasiAvoidMeagre (F := F) (A := A) hA, ?_‚ü©
  intro a ha
  -- Player II wins iff the intersection does *not* meet `A`.
  -- (The goal is expressed on streams via `Subtype.val ''`.)
  simp [game, interGame, payoffHits, Player.payoff]
  constructor
  ¬∑ -- Any play compatible with the strategy is a valid play in the underlying game tree.
    exact Descriptive.Tree.body_mono (PreStrategy.subtree_sub (S := (quasiAvoidMeagre (F := F) (A := A) hA).1) ) ha
  ¬∑ intro haTree hx
    rcases hx with ‚ü®x, hxA, hxI‚ü©
    -- Pick the index `k` with `x ‚àà N k`.
    have hxA' : x ‚àà ‚ãÉ n, (N n : Set X) := by simpa [hAeq] using hxA
    rcases Set.mem_iUnion.mp hxA' with ‚ü®k, hxNk‚ü©
    have hxcl : x ‚àà closure (N k : Set X) := subset_closure hxNk
    -- Show the intersection is contained in the (2k+1)-th played set, which the strategy ensured
    -- lies inside the complement of `closure (N k)`.
    have hxInMove : x ‚àà (a.get (2 * k + 1) : Set X) := by
      have hx' := (Set.mem_iInter.mp hxI) (2 * k + 1)
      simpa using hx'
    -- Extract compatibility at the Player II move `2k+1` to show it avoids `closure (N k)`.
    have hprefix_mem :
        a.take (2 * k + 1) ‚àà (quasiAvoidMeagre (F := F) (A := A) hA).1.subtree := by
      exact Descriptive.Tree.take_mem_body ha (2 * k + 1)
    let preNode : (quasiAvoidMeagre (F := F) (A := A) hA).1.subtree := ‚ü®_, hprefix_mem‚ü©
    have hpos : IsPosition preNode.val Player.one := by
      have : (2 * k + 1) % 2 = 1 := by omega
      simp [IsPosition, Player.toNat, preNode, this]
    have hnext_mem :
        preNode.val ++ [a.get (2 * k + 1)] ‚àà (quasiAvoidMeagre (F := F) (A := A) hA).1.subtree := by
      have ht : a.take (2 * k + 2) ‚àà (quasiAvoidMeagre (F := F) (A := A) hA).1.subtree :=
        Descriptive.Tree.take_mem_body ha (2 * k + 2)
      have htake' : a.take (2 * k + 2) = preNode.val ++ [a.get (2 * k + 1)] := by
        have hn : (2 * k + 1) + 1 = 2 * k + 2 := by omega
        simp [preNode, hn]
      simpa [htake'] using ht
    have hcompat :
        ‚ü®a.get (2 * k + 1), by exact hnext_mem.1‚ü©
          ‚àà (preAvoidMeagre (F := F) (A := A) hA)
              ((PreStrategy.subtree_incl _ preNode)) (by simpa using hpos) := by
      exact (preAvoidMeagre (F := F) (A := A) hA).subtree_compatible preNode (by simpa using hpos) hnext_mem
    have hAvoid : (a.get (2 * k + 1) : Set X) ‚äÜ (closure (N k : Set X))·∂ú := by
      intro z hz
      have hz' : z ‚àà (closure (N (preNode.val.length / 2) : Set X))·∂ú := (hcompat hz).2
      have hk : preNode.val.length / 2 = k := by
        simp [preNode]
      simpa [hk] using hz'
    have : x ‚àà (closure (N k : Set X))·∂ú := hAvoid hxInMove
    exact this hxcl

end Meagre

/-- A Banach‚ÄìMazur family in the classical sense: members need not be open, but must have nonempty
interior, and the family refines every nonempty open set. This matches the setup in standard
references (e.g. Oxtoby 1957, Telg√°rsky 1987). -/
structure FamilyBM (X : Type*) [TopologicalSpace X] where
  W : Set (Set X)
  interior_nonempty_mem : ‚àÄ {U}, U ‚àà W ‚Üí (interior U).Nonempty
  nonempty : ‚àÉ U, U ‚àà W
  refine_open : ‚àÄ {U}, IsOpen U ‚Üí U.Nonempty ‚Üí ‚àÉ V, V ‚àà W ‚àß V ‚äÜ U

namespace FamilyBM

variable {X : Type*} [TopologicalSpace X] (F : FamilyBM X)

def LocalBasis : Prop :=
  ‚àÄ x U, IsOpen U ‚Üí x ‚àà U ‚Üí ‚àÉ V, V ‚àà F.W ‚àß x ‚àà V ‚àß V ‚äÜ U

lemma nonempty_mem {U : Set X} (hU : U ‚àà F.W) : U.Nonempty := by
  rcases F.interior_nonempty_mem (U := U) hU with ‚ü®x, hx‚ü©
  exact ‚ü®x, interior_subset hx‚ü©

end FamilyBM

def gameBM {X : Type*} [TopologicalSpace X] (F : FamilyBM X) (A : Set X) : Game F.W :=
  interGame (X := X) (V := F.W) (PO := payoffHits (X := X) A)

section OpenFamilyBM

variable {X : Type*} [TopologicalSpace X] [Nonempty X]

noncomputable def openFamilyBM : FamilyBM X where
  W := {U : Set X | IsOpen U ‚àß U.Nonempty}
  interior_nonempty_mem := by
    intro U hU
    simpa [hU.1.interior_eq] using hU.2
  nonempty := ‚ü®Set.univ, isOpen_univ, Set.univ_nonempty‚ü©
  refine_open := by
    intro U hUo hUne
    exact ‚ü®U, ‚ü®hUo, hUne‚ü©, subset_rfl‚ü©

end OpenFamilyBM

lemma openFamilyBM_localBasis (X : Type*) [TopologicalSpace X] [Nonempty X] :
    (openFamilyBM (X := X)).LocalBasis := by
  intro x U hUo hxU
  refine ‚ü®U, ?_, hxU, subset_rfl‚ü©
  exact ‚ü®hUo, ‚ü®x, hxU‚ü©‚ü©

section ZornHelpers

open Set

variable {X : Type*} [TopologicalSpace X]

/-- `s` is dense within `U0` if every nonempty open `O ‚äÜ U0` meets `s`. -/
def DenseWithin (s U0 : Set X) : Prop :=
  ‚àÄ O, IsOpen O ‚Üí O ‚äÜ U0 ‚Üí O.Nonempty ‚Üí (O ‚à© s).Nonempty

/-- Nonempty open subsets of an ambient set `U0`. -/
structure OpenSub (U0 : Set X) where
  set : Set X
  isOpen : IsOpen set
  nonempty : set.Nonempty
  subset : set ‚äÜ U0

instance (U0 : Set X) : SetLike (OpenSub U0) X where
  coe := OpenSub.set
  coe_injective' := by
    intro U V h
    cases U
    cases V
    cases h
    rfl

@[simp] lemma OpenSub.coe_set {U0 : Set X} (U : OpenSub U0) : (U : Set X) = U.set := rfl

lemma OpenSub.nonempty_mem {U0 : Set X} (U : OpenSub U0) : (U : Set X).Nonempty := U.nonempty

def OpenSub.restrict {U0 U : Set X} (h : U ‚äÜ U0) (V : OpenSub U) : OpenSub U0 :=
  ‚ü®V.set, V.isOpen, V.nonempty, V.subset.trans h‚ü©

lemma exists_pairwiseDisjoint_image_denseWithin
    {U0 : Set X} (hU0 : IsOpen U0)
    (f : OpenSub U0 ‚Üí OpenSub U0)
    (hf : ‚àÄ U, (f U).set ‚äÜ U.set) :
    ‚àÉ ùí∞ : Set (OpenSub U0),
      ùí∞.Pairwise (fun U V => Disjoint (f U).set (f V).set) ‚àß
      DenseWithin (‚ãÉ U ‚àà ùí∞, (f U).set) U0 := by
  let S : Set (Set (OpenSub U0)) :=
    {A | A.Pairwise (fun U V => Disjoint (f U).set (f V).set)}
  have hchain :
      ‚àÄ c ‚äÜ S, IsChain (¬∑ ‚äÜ ¬∑) c ‚Üí
        ‚àÉ ub ‚àà S, ‚àÄ s ‚àà c, s ‚äÜ ub := by
    intro c hcS hc
    refine ‚ü®‚ãÉ‚ÇÄ c, ?_, ?_‚ü©
    ¬∑ -- pairwise disjointness is preserved along chains
      have hub :
          (‚ãÉ‚ÇÄ c).Pairwise (fun U V => Disjoint (f U).set (f V).set) := by
        intro U hU V hV hUV
        rcases Set.mem_sUnion.mp hU with ‚ü®A, hAc, hUA‚ü©
        rcases Set.mem_sUnion.mp hV with ‚ü®B, hBc, hVB‚ü©
        have hAB : A ‚äÜ B ‚à® B ‚äÜ A := hc.total hAc hBc
        cases hAB with
        | inl hAB =>
            have hpairB :
                B.Pairwise (fun U V => Disjoint (f U).set (f V).set) := by
              have : B ‚àà S := hcS hBc
              simpa [S] using this
            exact hpairB (hAB hUA) hVB hUV
        | inr hBA =>
            have hpairA :
                A.Pairwise (fun U V => Disjoint (f U).set (f V).set) := by
              have : A ‚àà S := hcS hAc
              simpa [S] using this
            exact hpairA hUA (hBA hVB) hUV
      simpa [S] using hub
    ¬∑ intro s hs
      exact Set.subset_sUnion_of_mem hs
  rcases zorn_subset S hchain with ‚ü®M, hMmax‚ü©
  have hMpair :
      M.Pairwise (fun U V => Disjoint (f U).set (f V).set) := by
    simpa [S] using hMmax.1
  let Ubig : Set X := ‚ãÉ U ‚àà M, (f U).set
  have hDense : DenseWithin Ubig U0 := by
    intro O hOo hOsub hOne
    by_contra hEmpty
    have hDisj : Disjoint (O ‚à© U0) Ubig := by
      refine Set.disjoint_left.2 ?_
      intro y hyO hyU
      exact hEmpty ‚ü®y, hyO.1, hyU‚ü©
    have hWopen : IsOpen (O ‚à© U0) := hOo.inter hU0
    have hWne : (O ‚à© U0).Nonempty := by
      rcases hOne with ‚ü®x, hx‚ü©
      exact ‚ü®x, ‚ü®hx, hOsub hx‚ü©‚ü©
    let W : OpenSub U0 :=
      ‚ü®O ‚à© U0, hWopen, hWne, by intro y hy; exact hy.2‚ü©
    let M' : Set (OpenSub U0) := M ‚à™ {W}
    have hM'S : M' ‚àà S := by
      have hpair :
          M'.Pairwise (fun U V => Disjoint (f U).set (f V).set) := by
        intro U hU V hV hUV
        have hU' : U ‚àà M ‚à® U = W := by
          rcases hU with hU | hU
          ¬∑ exact Or.inl hU
          ¬∑ exact Or.inr (by simpa [Set.mem_singleton_iff] using hU)
        have hV' : V ‚àà M ‚à® V = W := by
          rcases hV with hV | hV
          ¬∑ exact Or.inl hV
          ¬∑ exact Or.inr (by simpa [Set.mem_singleton_iff] using hV)
        cases hU' with
        | inl hUm =>
            cases hV' with
            | inl hVm =>
                exact hMpair hUm hVm hUV
            | inr hVw =>
                subst hVw
                have hsub : (f U).set ‚äÜ Ubig := by
                  intro y hy
                  exact Set.mem_iUnion‚ÇÇ.2 ‚ü®U, ‚ü®hUm, hy‚ü©‚ü©
                have hsubW : (f W).set ‚äÜ W.set := hf W
                refine Set.disjoint_left.2 ?_
                intro y hyU hyW
                have hyUbig : y ‚àà Ubig := hsub hyU
                have hyW' : y ‚àà W.set := hsubW hyW
                exact (Set.disjoint_left.1 hDisj) hyW' hyUbig
        | inr hUw =>
            subst hUw
            cases hV' with
            | inl hVm =>
                have hsub : (f V).set ‚äÜ Ubig := by
                  intro y hy
                  exact Set.mem_iUnion‚ÇÇ.2 ‚ü®V, ‚ü®hVm, hy‚ü©‚ü©
                have hsubW : (f W).set ‚äÜ W.set := hf W
                refine Set.disjoint_left.2 ?_
                intro y hyW hyV
                have hyUbig : y ‚àà Ubig := hsub hyV
                have hyW' : y ‚àà W.set := hsubW hyW
                exact (Set.disjoint_left.1 hDisj) hyW' hyUbig
            | inr hVw =>
                subst hVw
                exact (hUV rfl).elim
      simpa [S] using hpair
    have hMM' : M ‚äÜ M' := by intro U hU; exact Or.inl hU
    have hM'sub : M' ‚äÜ M := hMmax.2 hM'S hMM'
    have hEq : M' = M := by
      exact Set.Subset.antisymm hM'sub hMM'
    have hWmemM : W ‚àà M := by
      have : W ‚àà M' := Or.inr (by simp)
      simpa [hEq] using this
    have hWnonempty : (f W).set.Nonempty := (f W).nonempty
    rcases hWnonempty with ‚ü®y, hyfW‚ü©
    have hyUbig : y ‚àà Ubig := Set.mem_iUnion‚ÇÇ.2 ‚ü®W, ‚ü®hWmemM, hyfW‚ü©‚ü©
    have hyW : y ‚àà W.set := (hf W) hyfW
    exact (Set.disjoint_left.1 hDisj) hyW hyUbig
  refine ‚ü®M, hMpair, ?_‚ü©
  simpa [Ubig] using hDense

end ZornHelpers

section MeagreBM

variable {X : Type*} [TopologicalSpace X]
variable (F : FamilyBM X) {A : Set X}

noncomputable def preAvoidMeagreBM (hA : IsMeagre A) :
    PreStrategy (chainTree F.W) Player.one := by
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  refine fun x hp => by
    have hxne : x.val ‚â† [] := by
      intro h0
      have : x.val.length % 2 = 0 := by simp [h0]
      have : x.val.length % 2 = 1 := by simpa [IsPosition, Player.toNat] using hp
      omega
    let Uel : F.W := x.val.getLast hxne
    let U : Set X := interior (Uel : Set X)
    let k : ‚Ñï := x.val.length / 2
    exact {a | (a.val : Set X) ‚äÜ U ‚à© (closure (N k : Set X))·∂ú}

noncomputable def quasiAvoidMeagreBM (hA : IsMeagre A) :
    QuasiStrategy (chainTree F.W) Player.one := by
  let P : PreStrategy (chainTree F.W) Player.one := preAvoidMeagreBM (F := F) (A := A) hA
  refine ‚ü®P, ?_‚ü©
  intro x hp
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  have hxne : x.val ‚â† [] := by
    intro h0
    have : x.val.length % 2 = 0 := by simp [h0]
    have : x.val.length % 2 = 1 := by simpa [IsPosition, Player.toNat] using hp
    omega
  let Uel : F.W := x.val.getLast hxne
  let U : Set X := interior (Uel : Set X)
  have hUo : IsOpen U := isOpen_interior
  have hUne : U.Nonempty := by
    have : (interior (Uel : Set X)).Nonempty :=
      F.interior_nonempty_mem (U := Uel) Uel.property
    simpa using this
  let k : ‚Ñï := x.val.length / 2
  have hDense : Dense (closure (N k : Set X))·∂ú := by
    have hNW : IsNowhereDense (closure (N k : Set X)) := (N k).2.closure
    have : IsOpen (closure (N k : Set X))·∂ú ‚àß Dense (closure (N k : Set X))·∂ú := by
      simpa using (isClosed_isNowhereDense_iff_compl (s := closure (N k : Set X))).1
        ‚ü®isClosed_closure, hNW‚ü©
    exact this.2
  have hU'ne : (U ‚à© (closure (N k : Set X))·∂ú).Nonempty :=
    by simpa [Set.inter_comm] using hDense.inter_open_nonempty U hUo hUne
  let Vset : Set X := (F.refine_open (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose
  have hVmem : Vset ‚àà F.W := (F.refine_open (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose_spec.1
  have hVsub : Vset ‚äÜ U ‚à© (closure (N k : Set X))·∂ú := (F.refine_open
      (U := U ‚à© (closure (N k : Set X))·∂ú)
      (hUo.inter (isOpen_compl_iff.mpr isClosed_closure)) hU'ne).choose_spec.2
  let V : F.W := ‚ü®Vset, hVmem‚ü©
  have hVsubU : (V : Set X) ‚äÜ U := fun z hz => (hVsub hz).1
  have hExt : x.val ++ [V] ‚àà chainTree F.W := by
    rw [concat_mem_chainTree (V := F.W)]
    refine ‚ü®x.prop, fun _ => ?_‚ü©
    have hcurr : U = interior (x.val.getLast hxne : Set X) := rfl
    have hsub' : (V : Set X) ‚äÜ interior (x.val.getLast hxne : Set X) := by
      simpa [hcurr] using hVsubU
    exact fun y hy => interior_subset (hsub' hy)
  refine ‚ü®‚ü®V, hExt‚ü©, ?_‚ü©
  exact hVsub

theorem existsWinning_one_of_isMeagre_BM (A : Set X) (hA : IsMeagre A) :
    (gameBM (X := X) F A).ExistsWinning Player.one := by
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hA.eq_countable_union_isNowhereDense)
  have hAeq : A = ‚ãÉ n, (N n : Set X) :=
    Classical.choose_spec (hA.eq_countable_union_isNowhereDense)
  refine (GaleStewartGame.Game.existsWinning_iff_quasi
      (G := gameBM (X := X) F A) (p := Player.one)).2 ?_
  refine ‚ü®quasiAvoidMeagreBM (F := F) (A := A) hA, ?_‚ü©
  intro a ha
  simp [gameBM, interGame, payoffHits, Player.payoff]
  constructor
  ¬∑ exact Descriptive.Tree.body_mono
      (PreStrategy.subtree_sub (S := (quasiAvoidMeagreBM (F := F) (A := A) hA).1)) ha
  ¬∑ intro haTree hx
    rcases hx with ‚ü®x, hxA, hxI‚ü©
    have hxA' : x ‚àà ‚ãÉ n, (N n : Set X) := by simpa [hAeq] using hxA
    rcases Set.mem_iUnion.mp hxA' with ‚ü®k, hxNk‚ü©
    have hxcl : x ‚àà closure (N k : Set X) := subset_closure hxNk
    have hxInMove : x ‚àà (a.get (2 * k + 1) : Set X) := by
      have hx' := (Set.mem_iInter.mp hxI) (2 * k + 1)
      simpa using hx'
    have hprefix_mem :
        a.take (2 * k + 1) ‚àà (quasiAvoidMeagreBM (F := F) (A := A) hA).1.subtree := by
      exact Descriptive.Tree.take_mem_body ha (2 * k + 1)
    let preNode : (quasiAvoidMeagreBM (F := F) (A := A) hA).1.subtree := ‚ü®_, hprefix_mem‚ü©
    have hpos : IsPosition preNode.val Player.one := by
      have : (2 * k + 1) % 2 = 1 := by omega
      simp [IsPosition, Player.toNat, preNode, this]
    have hnext_mem :
        preNode.val ++ [a.get (2 * k + 1)] ‚àà (quasiAvoidMeagreBM (F := F) (A := A) hA).1.subtree := by
      have ht : a.take (2 * k + 2) ‚àà (quasiAvoidMeagreBM (F := F) (A := A) hA).1.subtree :=
        Descriptive.Tree.take_mem_body ha (2 * k + 2)
      have htake' : a.take (2 * k + 2) = preNode.val ++ [a.get (2 * k + 1)] := by
        have hn : (2 * k + 1) + 1 = 2 * k + 2 := by omega
        simp [preNode, hn]
      simpa [htake'] using ht
    have hcompat :
        ‚ü®a.get (2 * k + 1), by exact hnext_mem.1‚ü©
          ‚àà (preAvoidMeagreBM (F := F) (A := A) hA)
              ((PreStrategy.subtree_incl _ preNode)) (by simpa using hpos) := by
      exact (preAvoidMeagreBM (F := F) (A := A) hA).subtree_compatible preNode
        (by simpa using hpos) hnext_mem
    have hAvoid : (a.get (2 * k + 1) : Set X) ‚äÜ (closure (N k : Set X))·∂ú := by
      intro z hz
      have hz' : z ‚àà (closure (N (preNode.val.length / 2) : Set X))·∂ú := (hcompat hz).2
      have hk : preNode.val.length / 2 = k := by
        simp [preNode]
      simpa [hk] using hz'
    have : x ‚àà (closure (N k : Set X))·∂ú := hAvoid hxInMove
    exact this hxcl

theorem basis_invariant_one_of_isMeagre (F G : FamilyBM X) (A : Set X) (hA : IsMeagre A) :
    (gameBM (X := X) F A).ExistsWinning Player.one ‚àß
      (gameBM (X := X) G A).ExistsWinning Player.one :=
  ‚ü®existsWinning_one_of_isMeagre_BM (F := F) (A := A) hA,
    existsWinning_one_of_isMeagre_BM (F := G) (A := A) hA‚ü©

theorem existsWinning_zero_imp_not_isMeagre (F : FamilyBM X) (A : Set X)
    (hWin : (gameBM (X := X) F A).ExistsWinning Player.zero) : ¬¨ IsMeagre A := by
  intro hMeagre
  have hOne : (gameBM (X := X) F A).ExistsWinning Player.one :=
    existsWinning_one_of_isMeagre_BM (F := F) (A := A) hMeagre
  have hne : [] ‚àà (gameBM (X := X) F A).tree := by
    simpa [gameBM, interGame] using (nil_mem_chainTree (V := F.W))
  exact (GaleStewartGame.Game.ExistsWinning.not_both_winning
    (G := gameBM (X := X) F A) (p := Player.zero) hWin hne) hOne

theorem exists_open_nonempty_dense_of_existsWinning_zero (F : FamilyBM X) (A : Set X)
    (hWin : (gameBM (X := X) F A).ExistsWinning Player.zero) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß
      ‚àÄ O, IsOpen O ‚Üí O ‚äÜ U0 ‚Üí O.Nonempty ‚Üí (O ‚à© A).Nonempty := by
  obtain ‚ü®S, hSwin‚ü© := hWin
  -- Root move chosen by Player `zero`.
  have hroot : [] ‚àà S.pre.subtree := by
    simpa using (nil_mem_chainTree (V := F.W))
  let rootSub : S.pre.subtree := ‚ü®[], hroot‚ü©
  have hpos0 : IsPosition rootSub.val Player.zero := by
    simp [IsPosition, Player.toNat, rootSub]
  let a0 := S (S.pre.subtree_incl rootSub) hpos0
  let U0 : Set X := interior (a0.val : Set X)
  have hU0o : IsOpen U0 := isOpen_interior
  have hU0ne : U0.Nonempty := F.interior_nonempty_mem (U := a0.val) a0.val.property
  refine ‚ü®U0, hU0o, hU0ne, ?_‚ü©
  intro O hOo hOsub hOne
  -- Choose a move of Player `one` inside the given open set.
  rcases F.refine_open (U := O) hOo hOne with ‚ü®Vset, hVmem, hVsub‚ü©
  let V : F.W := ‚ü®Vset, hVmem‚ü©
  have hVsubU0 : (V : Set X) ‚äÜ U0 := fun x hx => hOsub (hVsub hx)
  have hVsubA0 : (V : Set X) ‚äÜ (a0.val : Set X) := fun x hx => interior_subset (hVsubU0 hx)
  -- First move of `S` appears in the subtree.
  have hprefix1 : rootSub.val ++ [a0.val] ‚àà S.pre.subtree := by
    have hx0 : rootSub.val ++ [a0.val] ‚àà chainTree (V := F.W) := a0.prop
    have hmem : ‚ü®a0.val, hx0‚ü© ‚àà S.pre (S.pre.subtree_incl rootSub) hpos0 := by
      have ha : (‚ü®a0.val, hx0‚ü© : Descriptive.Tree.ExtensionsAt (S.pre.subtree_incl rootSub)) = a0 := by
        apply Descriptive.Tree.ExtensionsAt.ext
        rfl
      simpa [Strategy.pre, ha]
    exact (S.pre.subtree_compatible_iff rootSub hpos0).2 ‚ü®hx0, hmem‚ü©
  let x1 : S.pre.subtree := ‚ü®rootSub.val ++ [a0.val], hprefix1‚ü©
  have hpos1 : IsPosition x1.val Player.one := by
    simp [IsPosition, Player.toNat, x1, rootSub]
  -- Player `one` may choose `V` at the next move.
  have hprefix2 : x1.val ++ [V] ‚àà S.pre.subtree := by
    have hx1_tree : x1.val ‚àà chainTree (V := F.W) := (S.pre.subtree_sub x1.prop)
    have hconcat : x1.val ++ [V] ‚àà chainTree (V := F.W) := by
      rw [concat_mem_chainTree (V := F.W)]
      refine ‚ü®hx1_tree, ?_‚ü©
      intro hxne
      have : x1.val.getLast hxne = a0.val := by
        simp [x1, rootSub]
      simpa [this] using hVsubA0
    simpa [x1] using (S.pre.subtree_fair x1 hpos1).2 hconcat
  let pref : List F.W := x1.val ++ [V]
  -- Build an infinite play extending the prefix `pref`.
  have hpruned_tree : Descriptive.Tree.IsPruned (chainTree (V := F.W)) := by
    intro x
    by_cases hx : x.val = []
    ¬∑ rcases F.nonempty with ‚ü®U, hU‚ü©
      let V' : F.W := ‚ü®U, hU‚ü©
      have : x.val ++ [V'] ‚àà chainTree (V := F.W) := by
        simp [hx, chainTree]
      exact ‚ü®‚ü®V', this‚ü©‚ü©
    ¬∑
      let Uel : F.W := x.val.getLast hx
      let U : Set X := interior (Uel : Set X)
      have hUo : IsOpen U := isOpen_interior
      have hUne : U.Nonempty := F.interior_nonempty_mem (U := Uel) Uel.property
      rcases F.refine_open (U := U) hUo hUne with ‚ü®Vset', hVmem', hVsub'‚ü©
      let V' : F.W := ‚ü®Vset', hVmem'‚ü©
      have hsub : (V' : Set X) ‚äÜ x.val.getLast hx := by
        intro y hy; exact interior_subset (hVsub' hy)
      have hconcat : x.val ++ [V'] ‚àà chainTree (V := F.W) := by
        rw [concat_mem_chainTree (V := F.W)]
        refine ‚ü®x.prop, ?_‚ü©
        intro _; exact hsub
      exact ‚ü®‚ü®V', hconcat‚ü©‚ü©
  have hpruned_sub : Descriptive.Tree.IsPruned S.pre.subtree :=
    (S.quasi.subtree_isPruned hpruned_tree)
  have hpruned_pref : Descriptive.Tree.IsPruned (Descriptive.Tree.subAt S.pre.subtree pref) :=
    hpruned_sub.sub pref
  have hpref : pref ‚àà S.pre.subtree := by
    simpa [pref] using hprefix2
  have hbody_pref :
      (Descriptive.Tree.body (Descriptive.Tree.subAt S.pre.subtree pref)).Nonempty := by
    simpa [hpref] using
      (Descriptive.Tree.IsPruned.body_ne_iff_ne
        (T := Descriptive.Tree.subAt S.pre.subtree pref) hpruned_pref).2 (by simp [hpref])
  rcases hbody_pref with ‚ü®b, hb‚ü©
  let a : Descriptive.Tree.body S.pre.subtree :=
    Descriptive.Tree.body.append (T := S.pre.subtree) pref ‚ü®b, hb‚ü©
  -- Apply the winning property of `S`.
  rcases hSwin a.prop with ‚ü®ha_tree, hpay‚ü©
  have hpay' : (A ‚à© ‚ãÇ n, (a.val.get n : Set X)).Nonempty := by
    have hpay0 : (A ‚à© ‚ãÇ n, ((ha_tree : Descriptive.Tree.body (chainTree F.W)).val.get n : Set X)).Nonempty := by
      simpa [gameBM, interGame, payoffHits, Player.payoff] using hpay.1
    simpa [hpay.2] using hpay0
  rcases hpay' with ‚ü®x, hxA, hxI‚ü©
  have hxV : x ‚àà (a.val.get 1 : Set X) := by
    have := (Set.mem_iInter.mp hxI) 1
    simpa using this
  have hget1 : a.val.get 1 = V := by
    have hlt : (1 : ‚Ñï) < pref.length := by
      simp [pref, x1]
    have h := (Stream'.get_append_left (x := pref) (a := b) (n := 1) hlt)
    simpa [a, Descriptive.Tree.body.append, pref, x1] using h
  have hxO : x ‚àà O := by
    have hxV' : x ‚àà (V : Set X) := by simpa [hget1] using hxV
    exact hVsub hxV'
  exact ‚ü®x, ‚ü®hxO, hxA‚ü©‚ü©

end MeagreBM

section Unconditional

open Set

variable {X : Type*} [TopologicalSpace X]
variable (F : FamilyBM X)

structure Node (S : Strategy (chainTree F.W) Player.zero) where
  hist : List F.W
  mem : hist ‚àà S.pre.subtree
  odd : IsPosition hist Player.one

namespace Node

variable {F} {S : Strategy (chainTree F.W) Player.zero}

lemma hist_in_tree (x : Node (F := F) S) : x.hist ‚àà chainTree F.W :=
  S.pre.subtree_sub x.mem

lemma ne_nil (x : Node (F := F) S) : x.hist ‚â† [] := by
  intro h0
  have : x.hist.length % 2 = 0 := by simp [h0]
  have : x.hist.length % 2 = 1 := by
    simpa [IsPosition, Player.toNat, h0] using x.odd
  omega

noncomputable def openSet (x : Node (F := F) S) : Set X :=
  interior (x.hist.getLast (x.ne_nil) : Set X)

lemma openSet_isOpen (x : Node (F := F) S) : IsOpen (x.openSet) := isOpen_interior

lemma openSet_nonempty (x : Node (F := F) S) :
    (x.openSet).Nonempty := by
  have hne :
      (interior (x.hist.getLast (x.ne_nil) : Set X)).Nonempty :=
    F.interior_nonempty_mem (U := x.hist.getLast (x.ne_nil)) (x.hist.getLast (x.ne_nil)).property
  simpa [Node.openSet] using hne

lemma openSet_subset_last (x : Node (F := F) S) :
    x.openSet ‚äÜ (x.hist.getLast (x.ne_nil) : Set X) :=
  interior_subset

lemma odd_length (x : Node (F := F) S) : x.hist.length % 2 = 1 := by
  simpa [IsPosition, Player.toNat] using x.odd

lemma pos_append (x : Node (F := F) S) (V : F.W) :
    IsPosition (x.hist ++ [V]) Player.zero := by
  have hodd : x.hist.length % 2 = 1 := odd_length x
  have : (x.hist.length + 1) % 2 = 0 := by omega
  simpa [IsPosition, Player.toNat, List.length_append] using this

lemma odd_append_two (x : Node (F := F) S) (V a : F.W) :
    IsPosition (x.hist ++ [V] ++ [a]) Player.one := by
  have hodd : x.hist.length % 2 = 1 := odd_length x
  have : (x.hist.length + 1 + 1) % 2 = 1 := by omega
  simpa [IsPosition, Player.toNat, List.length_append, Nat.add_assoc] using this

end Node

noncomputable def rootNode
    (S : Strategy (chainTree F.W) Player.zero)
    (hroot : [] ‚àà chainTree F.W) :
    Node (F := F) S := by
  have hroot_sub : [] ‚àà S.pre.subtree := by
    simpa [Strategy.pre] using (S.pre.subtree_ne (T := chainTree F.W)).2 hroot
  let rootSub : S.pre.subtree := ‚ü®[], hroot_sub‚ü©
  have hpos0 : IsPosition rootSub.val Player.zero := by
    simp [IsPosition, Player.toNat, rootSub]
  let a0 := S (S.pre.subtree_incl rootSub) hpos0
  have hprefix : rootSub.val ++ [a0.val] ‚àà S.pre.subtree := by
    have hiff := (S.pre.subtree_compatible_iff rootSub hpos0 (a := a0.val))
    refine (hiff.mpr ?_)
    refine ‚ü®a0.prop, ?_‚ü©
    simp [Strategy.pre, a0]
  refine ‚ü®[a0.val], ?_, ?_‚ü©
  ¬∑ simpa [rootSub] using hprefix
  ¬∑ simp [IsPosition, Player.toNat]

section LocalBasisData

variable {A : Set X}
variable {S : Strategy (chainTree F.W) Player.zero}

noncomputable def chooseV_exists (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) :
    ‚àÉ V : Set X, V ‚àà F.W ‚àß V ‚äÜ U.set := by
  rcases U.nonempty with ‚ü®y, hy‚ü©
  rcases hLB y U.set U.isOpen hy with ‚ü®V, hVmem, hyV, hVsub‚ü©
  exact ‚ü®V, hVmem, hVsub‚ü©

noncomputable def chooseV (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) : F.W :=
  ‚ü®Classical.choose (chooseV_exists (F := F) x hLB U),
    (Classical.choose_spec (chooseV_exists (F := F) x hLB U)).1‚ü©

lemma chooseV_subset (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) :
    (chooseV (F := F) x hLB U : Set X) ‚äÜ U.set :=
  (Classical.choose_spec (chooseV_exists (F := F) x hLB U)).2

noncomputable def nextMove (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) : F.W := by
  let V : F.W := chooseV (F := F) x hLB U
  have hxTree : x.hist ++ [V] ‚àà chainTree F.W := by
    rw [concat_mem_chainTree (V := F.W)]
    refine ‚ü®x.hist_in_tree, ?_‚ü©
    intro hxne
    have hVsub : (V : Set X) ‚äÜ (x.hist.getLast hxne : Set X) := by
      have hVsubU : (V : Set X) ‚äÜ U.set :=
        chooseV_subset (F := F) x hLB U
      have hUsub : U.set ‚äÜ Node.openSet x := U.subset
      have hOpenSub : Node.openSet x ‚äÜ (x.hist.getLast hxne : Set X) :=
        Node.openSet_subset_last x
      exact (hVsubU.trans hUsub).trans hOpenSub
    exact hVsub
  have hxSub : x.hist ++ [V] ‚àà S.pre.subtree := by
    have hpos1' :
        IsPosition ( (‚ü®x.hist, x.mem‚ü© : S.pre.subtree).val ) Player.zero.swap := by
      simpa [Player.swap] using x.odd
    have hiff := (S.pre.subtree_fair (x := (‚ü®x.hist, x.mem‚ü© : S.pre.subtree)) (a := V) hpos1')
    exact (hiff.mpr hxTree)
  let nodeSub : S.pre.subtree := ‚ü®x.hist ++ [V], hxSub‚ü©
  have hpos : IsPosition (x.hist ++ [V]) Player.zero := Node.pos_append (x := x) V
  exact (S (S.pre.subtree_incl nodeSub) hpos).val

lemma nextMove_subset (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) :
    (nextMove (F := F) x hLB U : Set X) ‚äÜ
      (chooseV (F := F) x hLB U : Set X) := by
  -- unfold `nextMove`
  -- reintroduce the local definitions explicitly
  let V : F.W := chooseV (F := F) x hLB U
  have hxTree : x.hist ++ [V] ‚àà chainTree F.W := by
    rw [concat_mem_chainTree (V := F.W)]
    refine ‚ü®x.hist_in_tree, ?_‚ü©
    intro hxne
    have hVsubU : (V : Set X) ‚äÜ U.set :=
      chooseV_subset (F := F) x hLB U
    have hUsub : U.set ‚äÜ Node.openSet x := U.subset
    have hOpenSub : Node.openSet x ‚äÜ (x.hist.getLast hxne : Set X) :=
      Node.openSet_subset_last x
    exact (hVsubU.trans hUsub).trans hOpenSub
  have hxSub : x.hist ++ [V] ‚àà S.pre.subtree := by
    have hpos1' :
        IsPosition ( (‚ü®x.hist, x.mem‚ü© : S.pre.subtree).val ) Player.zero.swap := by
      simpa [Player.swap] using x.odd
    have hiff := (S.pre.subtree_fair (x := (‚ü®x.hist, x.mem‚ü© : S.pre.subtree)) (a := V) hpos1')
    exact (hiff.mpr hxTree)
  let nodeSub : S.pre.subtree := ‚ü®x.hist ++ [V], hxSub‚ü©
  have hpos : IsPosition (x.hist ++ [V]) Player.zero := Node.pos_append (x := x) V
  let a := S (S.pre.subtree_incl nodeSub) hpos
  have hxTree' : x.hist ++ [V] ++ [a.val] ‚àà chainTree F.W := a.prop
  have hsub : (a.val : Set X) ‚äÜ (x.hist ++ [V]).getLast (by simp) := by
    have h := (concat_mem_chainTree (V := F.W) (x := x.hist ++ [V]) (A := a.val)).1 hxTree'
    exact h.2 (by simp)
  have hlast : (x.hist ++ [V]).getLast (by simp) = V := by
    simp
  simpa [nextMove] using hsub

noncomputable def nextOpen (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) : OpenSub (Node.openSet x) := by
  let a : F.W := nextMove (F := F) x hLB U
  refine ‚ü®interior (a : Set X), isOpen_interior, ?_, ?_‚ü©
  ¬∑ have hne := F.interior_nonempty_mem (U := a) a.property
    simpa using hne
  ¬∑ intro y hy
    have hy' : y ‚àà (a : Set X) := interior_subset hy
    have hsub : (a : Set X) ‚äÜ (chooseV (F := F) x hLB U : Set X) :=
      nextMove_subset (F := F) x hLB U
    have hsubU : (chooseV (F := F) x hLB U : Set X) ‚äÜ U.set :=
      chooseV_subset (F := F) x hLB U
    have hUsub : U.set ‚äÜ Node.openSet x := U.subset
    exact hUsub (hsubU (hsub hy'))

lemma nextOpen_subset (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) :
    (nextOpen (F := F) x hLB U).set ‚äÜ U.set := by
  intro y hy
  have hsub : (nextOpen (F := F) x hLB U).set ‚äÜ Node.openSet x :=
    (nextOpen (F := F) x hLB U).subset
  have hy' : y ‚àà Node.openSet x := hsub hy
  have hsub' : (nextOpen (F := F) x hLB U).set ‚äÜ
      (chooseV (F := F) x hLB U : Set X) := by
    intro z hz
    have hz' : z ‚àà (nextMove (F := F) x hLB U : Set X) := by
      exact interior_subset hz
    exact (nextMove_subset (F := F) x hLB U) hz'
  exact (chooseV_subset (F := F) x hLB U) (hsub' hy)

noncomputable def childFamily (x : Node (F := F) S)
    (hLB : F.LocalBasis) :
    {ùí∞ : Set (OpenSub (Node.openSet x)) //
      ùí∞.Pairwise (fun U V =>
        Disjoint (nextOpen (F := F) x hLB U).set (nextOpen (F := F) x hLB V).set) ‚àß
      DenseWithin (‚ãÉ U ‚àà ùí∞, (nextOpen (F := F) x hLB U).set) (Node.openSet x)} := by
  have hU0o : IsOpen (Node.openSet x) := Node.openSet_isOpen x
  let h :=
    exists_pairwiseDisjoint_image_denseWithin
      (U0 := Node.openSet x) hU0o
      (f := fun U => nextOpen (F := F) x hLB U)
      (hf := nextOpen_subset (F := F) x hLB)
  refine ‚ü®Classical.choose h, ?_‚ü©
  exact Classical.choose_spec h

noncomputable def childNode (x : Node (F := F) S)
    (hLB : F.LocalBasis) (U : OpenSub (Node.openSet x)) :
    Node (F := F) S := by
  let V : F.W := chooseV (F := F) x hLB U
  have hxTree : x.hist ++ [V] ‚àà chainTree F.W := by
    rw [concat_mem_chainTree (V := F.W)]
    refine ‚ü®x.hist_in_tree, ?_‚ü©
    intro hxne
    have hVsubU : (V : Set X) ‚äÜ U.set :=
      chooseV_subset (F := F) x hLB U
    have hUsub : U.set ‚äÜ Node.openSet x := U.subset
    have hOpenSub : Node.openSet x ‚äÜ (x.hist.getLast hxne : Set X) :=
      Node.openSet_subset_last x
    exact (hVsubU.trans hUsub).trans hOpenSub
  have hpos0 : IsPosition (x.hist ++ [V]) Player.zero := Node.pos_append (x := x) V
  have hxSub : x.hist ++ [V] ‚àà S.pre.subtree := by
    have hpos1' :
        IsPosition ( (‚ü®x.hist, x.mem‚ü© : S.pre.subtree).val ) Player.zero.swap := by
      simpa [Player.swap] using x.odd
    have hiff := (S.pre.subtree_fair (x := (‚ü®x.hist, x.mem‚ü© : S.pre.subtree)) (a := V) hpos1')
    exact (hiff.mpr hxTree)
  let nodeSub : S.pre.subtree := ‚ü®x.hist ++ [V], hxSub‚ü©
  let a := S (S.pre.subtree_incl nodeSub) hpos0
  have hxTree' : x.hist ++ [V] ++ [a.val] ‚àà chainTree F.W := a.prop
  have hprefix : x.hist ++ [V] ++ [a.val] ‚àà S.pre.subtree := by
    have hiff := (S.pre.subtree_compatible_iff nodeSub hpos0 (a := a.val))
    refine (hiff.mpr ?_)
    refine ‚ü®hxTree', ?_‚ü©
    simp [Strategy.pre, a]
  refine ‚ü®x.hist ++ [V] ++ [a.val], hprefix, ?_‚ü©
  simpa using Node.odd_append_two (x := x) V a.val

lemma childNode_openSet (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) :
    Node.openSet (childNode (F := F) x hLB U) =
      (nextOpen (F := F) x hLB U).set := by
  simp [childNode, nextOpen, nextMove, Node.openSet]

lemma childNode_openSet_subset (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) :
    Node.openSet (childNode (F := F) x hLB U) ‚äÜ Node.openSet x := by
  simpa [childNode_openSet] using (nextOpen (F := F) x hLB U).subset

end LocalBasisData

end Unconditional

section CompleteMetric

open Topology Metric

variable {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X]
open residual.dom

/-- The family of all closed balls of positive radius. -/
noncomputable def closedBallFamily : FamilyBM X where
  W := {U | ‚àÉ x r, 0 < r ‚àß U = closedBall x r}
  interior_nonempty_mem := by
    intro U hU
    rcases hU with ‚ü®x, r, hr, rfl‚ü©
    have hne : (ball x r).Nonempty := ‚ü®x, Metric.mem_ball_self hr‚ü©
    exact hne.mono (ball_subset_interior_closedBall (x := x) (Œµ := r))
  nonempty := by
    classical
    refine ‚ü®closedBall (Classical.choice (show Nonempty X from inferInstance)) 1, ?_‚ü©
    exact ‚ü®_, 1, by norm_num, rfl‚ü©
  refine_open := by
    intro U hUo hUne
    rcases hUne with ‚ü®x, hx‚ü©
    rcases Metric.isOpen_iff.1 hUo x hx with ‚ü®r, hrpos, hrsub‚ü©
    refine ‚ü®closedBall x (r / 2), ?_, ?_‚ü©
    ¬∑ refine ‚ü®x, r / 2, by nlinarith, rfl‚ü©
    ¬∑ intro y hy
      apply hrsub
      have : dist y x < r := lt_of_le_of_lt hy (by nlinarith)
      simpa [Metric.mem_ball] using this

lemma closedBallFamily_localBasis (X : Type*) [MetricSpace X] [Nonempty X] :
    (closedBallFamily (X := X)).LocalBasis := by
  intro x U hUo hxU
  rcases Metric.isOpen_iff.1 hUo x hxU with ‚ü®Œµ, hŒµpos, hŒµsub‚ü©
  let r : ‚Ñù := Œµ / 2
  have hrpos : 0 < r := by
    have : 0 < Œµ / 2 := by nlinarith
    simpa [r] using this
  have hsub : closedBall x r ‚äÜ U := by
    intro y hy
    apply hŒµsub
    have hrlt : r < Œµ := by
      have : Œµ / 2 < Œµ := by nlinarith
      simpa [r] using this
    have : dist y x < Œµ := lt_of_le_of_lt hy hrlt
    simpa [Metric.mem_ball] using this
  refine ‚ü®closedBall x r, ?_, ?_, hsub‚ü©
  ¬∑ exact ‚ü®x, r, hrpos, rfl‚ü©
  ¬∑
    have : dist x x ‚â§ r := by simpa [dist_self] using (le_of_lt hrpos)
    simpa [Metric.mem_closedBall] using this

omit [CompleteSpace X] [Nonempty X] in
lemma exists_closedBall_subset (O : Set X) (hO : IsOpen O) (hOne : O.Nonempty) (n : ‚Ñï) :
    ‚àÉ c r, 0 < r ‚àß r ‚â§ (1 / (n + 1 : ‚Ñù)) ‚àß closedBall c r ‚äÜ O := by
  rcases hOne with ‚ü®c, hc‚ü©
  rcases Metric.isOpen_iff.1 hO c hc with ‚ü®Œµ, hŒµpos, hŒµsub‚ü©
  let r : ‚Ñù := min (Œµ / 2) (1 / (n + 1 : ‚Ñù))
  have hrpos : 0 < r := by
    have : 0 < Œµ / 2 := by nlinarith
    exact lt_min this (by
      have : (0 : ‚Ñù) < (n + 1 : ‚Ñù) := by exact_mod_cast (Nat.succ_pos _)
      exact one_div_pos.2 this)
  have hrle : r ‚â§ (1 / (n + 1 : ‚Ñù)) := min_le_right _ _
  have hrlt : r < Œµ := by
    have : r ‚â§ Œµ / 2 := min_le_left _ _
    exact lt_of_le_of_lt this (by nlinarith)
  have hsub : closedBall c r ‚äÜ O := by
    intro y hy
    apply hŒµsub
    exact (closedBall_subset_ball hrlt) hy
  exact ‚ü®c, r, hrpos, hrle, hsub‚ü©

omit [CompleteSpace X] [Nonempty X] in
lemma exists_ball_subset_of_isOpen_lt {U : Set X} (hU : IsOpen U) {x : X} (hx : x ‚àà U)
    {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) :
    ‚àÉ Œµ, 0 < Œµ ‚àß Œµ < Œ¥ ‚àß Metric.ball x Œµ ‚äÜ U := by
  rcases Metric.isOpen_iff.1 hU x hx with ‚ü®Œµ0, hŒµ0pos, hŒµ0sub‚ü©
  let Œµ : ‚Ñù := min Œµ0 (Œ¥ / 2)
  have hŒµpos : 0 < Œµ := by
    have : 0 < Œ¥ / 2 := by nlinarith
    exact lt_min hŒµ0pos this
  have hŒµlt : Œµ < Œ¥ := by
    have : Œµ ‚â§ Œ¥ / 2 := min_le_right _ _
    exact lt_of_le_of_lt this (by nlinarith)
  have hsub : Metric.ball x Œµ ‚äÜ U := by
    intro y hy
    apply hŒµ0sub
    have : dist y x < Œµ0 := lt_of_lt_of_le hy (min_le_left _ _)
    simpa [Metric.mem_ball] using this
  exact ‚ü®Œµ, hŒµpos, hŒµlt, hsub‚ü©

section Shrinking

variable {F : FamilyBM X}
variable {S : Strategy (chainTree F.W) Player.zero}

noncomputable def shrinkRadius (n : ‚Ñï) : ‚Ñù := 1 / ((n : ‚Ñù) + 1)

lemma shrinkRadius_pos (n : ‚Ñï) : 0 < shrinkRadius (n := n) := by
  have : (0 : ‚Ñù) < (n + 1 : ‚Ñù) := by exact_mod_cast (Nat.succ_pos _)
  exact one_div_pos.2 this

omit [CompleteSpace X] [Nonempty X] in
lemma exists_shrinkOpen (x : Node (F := F) S) (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    ‚àÉ V : OpenSub (Node.openSet x), ‚àÉ c r, 0 < r ‚àß r < shrinkRadius (n := n) ‚àß
      V.set = Metric.ball c r ‚àß V.set ‚äÜ U.set := by
  rcases U.nonempty with ‚ü®y, hy‚ü©
  have hŒ¥ : 0 < shrinkRadius (n := n) := shrinkRadius_pos (n := n)
  rcases exists_ball_subset_of_isOpen_lt (X := X) (U := U.set) (hU := U.isOpen)
      (hx := hy) hŒ¥ with ‚ü®Œµ, hŒµpos, hŒµlt, hsub‚ü©
  let V : OpenSub (Node.openSet x) :=
    ‚ü®Metric.ball y Œµ, Metric.isOpen_ball, ‚ü®y, Metric.mem_ball_self hŒµpos‚ü©,
      by
        intro z hz
        exact U.subset (hsub hz)‚ü©
  refine ‚ü®V, y, Œµ, hŒµpos, hŒµlt, rfl, hsub‚ü©

noncomputable def shrinkOpen (x : Node (F := F) S) (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    OpenSub (Node.openSet x) :=
  Classical.choose (exists_shrinkOpen (F := F) (S := S) x U n)

omit [CompleteSpace X] [Nonempty X] in
lemma shrinkOpen_spec (x : Node (F := F) S) (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    ‚àÉ c r, 0 < r ‚àß r < shrinkRadius (n := n) ‚àß
      (shrinkOpen (F := F) (S := S) x U n).set = Metric.ball c r ‚àß
        (shrinkOpen (F := F) (S := S) x U n).set ‚äÜ U.set :=
  Classical.choose_spec (exists_shrinkOpen (F := F) (S := S) x U n)

omit [CompleteSpace X] [Nonempty X] in
lemma shrinkOpen_subset (x : Node (F := F) S) (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    (shrinkOpen (F := F) (S := S) x U n).set ‚äÜ U.set := by
  rcases shrinkOpen_spec (F := F) (S := S) x U n with ‚ü®_, _, _, _, _, hsub‚ü©
  exact hsub

noncomputable def nextMove_shrink (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) : F.W :=
  nextMove (F := F) x hLB (shrinkOpen (F := F) (S := S) x U n)

noncomputable def nextOpen_shrink (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) : OpenSub (Node.openSet x) :=
  nextOpen (F := F) x hLB (shrinkOpen (F := F) (S := S) x U n)

omit [CompleteSpace X] [Nonempty X] in
lemma nextOpen_shrink_subset (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    (nextOpen_shrink (F := F) (S := S) x hLB U n).set ‚äÜ U.set := by
  intro y hy
  have hsub1 :
      (nextOpen_shrink (F := F) (S := S) x hLB U n).set ‚äÜ
        (shrinkOpen (F := F) (S := S) x U n).set := by
    simpa [nextOpen_shrink] using
      (nextOpen_subset (F := F) (S := S) (x := x) (hLB := hLB)
        (U := shrinkOpen (F := F) (S := S) x U n))
  have hsub2 :
      (shrinkOpen (F := F) (S := S) x U n).set ‚äÜ U.set :=
    shrinkOpen_subset (F := F) (S := S) x U n
  exact hsub2 (hsub1 hy)

omit [CompleteSpace X] [Nonempty X] in
lemma nextMove_shrink_subset_ball (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    ‚àÉ c r, 0 < r ‚àß r < shrinkRadius (n := n) ‚àß
      (nextMove_shrink (F := F) (S := S) x hLB U n : Set X) ‚äÜ Metric.ball c r := by
  rcases shrinkOpen_spec (F := F) (S := S) x U n with ‚ü®c, r, hrpos, hrl, hEq, hsubU‚ü©
  refine ‚ü®c, r, hrpos, hrl, ?_‚ü©
  have hsub1 :
      (nextMove_shrink (F := F) (S := S) x hLB U n : Set X) ‚äÜ
        (shrinkOpen (F := F) (S := S) x U n).set := by
    have h1 :
        (nextMove (F := F) x hLB (shrinkOpen (F := F) (S := S) x U n) : Set X) ‚äÜ
          (chooseV (F := F) x hLB (shrinkOpen (F := F) (S := S) x U n) : Set X) :=
      nextMove_subset (F := F) (S := S) (x := x) (hLB := hLB)
        (U := shrinkOpen (F := F) (S := S) x U n)
    have h2 :
        (chooseV (F := F) x hLB (shrinkOpen (F := F) (S := S) x U n) : Set X) ‚äÜ
          (shrinkOpen (F := F) (S := S) x U n).set :=
      chooseV_subset (F := F) (S := S) (x := x) (hLB := hLB)
        (U := shrinkOpen (F := F) (S := S) x U n)
    simpa [nextMove_shrink] using h1.trans h2
  simpa [hEq] using hsub1

noncomputable def childFamily_shrink (x : Node (F := F) S)
    (hLB : F.LocalBasis) (n : ‚Ñï) :
    {ùí∞ : Set (OpenSub (Node.openSet x)) //
      ùí∞.Pairwise (fun U V =>
        Disjoint (nextOpen_shrink (F := F) (S := S) x hLB U n).set
          (nextOpen_shrink (F := F) (S := S) x hLB V n).set) ‚àß
      DenseWithin (‚ãÉ U ‚àà ùí∞, (nextOpen_shrink (F := F) (S := S) x hLB U n).set)
        (Node.openSet x)} := by
  have hU0o : IsOpen (Node.openSet x) := Node.openSet_isOpen x
  let h :=
    exists_pairwiseDisjoint_image_denseWithin
      (U0 := Node.openSet x) hU0o
      (f := fun U => nextOpen_shrink (F := F) (S := S) x hLB U n)
      (hf := fun U => nextOpen_shrink_subset (F := F) (S := S) (x := x) (hLB := hLB) (U := U) (n := n))
  refine ‚ü®Classical.choose h, ?_‚ü©
  exact Classical.choose_spec h

noncomputable def childNode_shrink (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) : Node (F := F) S :=
  childNode (F := F) (S := S) x hLB (shrinkOpen (F := F) (S := S) x U n)

omit [CompleteSpace X] [Nonempty X] in
lemma childNode_shrink_openSet (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    Node.openSet (childNode_shrink (F := F) (S := S) x hLB U n) =
      (nextOpen_shrink (F := F) (S := S) x hLB U n).set := by
  simpa [childNode_shrink, nextOpen_shrink] using
    (childNode_openSet (F := F) (S := S) (x := x) (hLB := hLB)
      (U := shrinkOpen (F := F) (S := S) x U n))

omit [CompleteSpace X] [Nonempty X] in
lemma childNode_shrink_openSet_subset (x : Node (F := F) S) (hLB : F.LocalBasis)
    (U : OpenSub (Node.openSet x)) (n : ‚Ñï) :
    Node.openSet (childNode_shrink (F := F) (S := S) x hLB U n) ‚äÜ Node.openSet x := by
  simpa [childNode_shrink_openSet] using
    (nextOpen_shrink (F := F) (S := S) x hLB U n).subset

end Shrinking

theorem existsWinning_zero_of_isMeagre_diff (A U0 : Set X) (hU0o : IsOpen U0)
    (hU0ne : U0.Nonempty) (hMeagre : IsMeagre (U0 \ A)) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  -- Decompose the complement in `U0` as a countable union of nowhere dense sets.
  let N : ‚Ñï ‚Üí {t : Set X // IsNowhereDense t} :=
    Classical.choose (hMeagre.eq_countable_union_isNowhereDense)
  have hUAeq : U0 \ A = ‚ãÉ n, (N n : Set X) :=
    Classical.choose_spec (hMeagre.eq_countable_union_isNowhereDense)
  -- Current open set along a finite play.
  let currOpen : List (closedBallFamily (X := X)).W ‚Üí Set X := fun x =>
    match x.getLast? with
    | none => U0
    | some U => interior (U : Set X)
  have hcurrOpen_open : ‚àÄ x, IsOpen (currOpen x) := by
    intro x; cases h : x.getLast? <;> simp [currOpen, h, hU0o, isOpen_interior]
  have hcurrOpen_nonempty : ‚àÄ x, (currOpen x).Nonempty := by
    intro x; cases h : x.getLast? with
    | none =>
        simpa [currOpen, h] using hU0ne
    | some U =>
        have : (interior (U : Set X)).Nonempty :=
          (closedBallFamily (X := X)).interior_nonempty_mem (U := U) U.property
        simpa [currOpen, h] using this
  -- A quasistrategy that lets Player `zero` pick a small closed ball avoiding `N n`.
  let P : PreStrategy (chainTree (closedBallFamily (X := X)).W) Player.zero := by
    intro x hp
    let n : ‚Ñï := x.val.length / 2
    exact {a | ‚àÉ c r, 0 < r ‚àß (a.val : Set X) = closedBall c r ‚àß
      r ‚â§ (1 / (n + 1 : ‚Ñù)) ‚àß
      (a.val : Set X) ‚äÜ currOpen x.val ‚à© (closure (N n : Set X))·∂ú}
  have hPquasi : P.IsQuasi := by
    intro x hp
    let n : ‚Ñï := x.val.length / 2
    let O : Set X := currOpen x.val ‚à© (closure (N n : Set X))·∂ú
    have hDense : Dense (closure (N n : Set X))·∂ú := by
      have hNW : IsNowhereDense (closure (N n : Set X)) := (N n).2.closure
      have : IsOpen (closure (N n : Set X))·∂ú ‚àß Dense (closure (N n : Set X))·∂ú := by
        simpa using (isClosed_isNowhereDense_iff_compl (s := closure (N n : Set X))).1
          ‚ü®isClosed_closure, hNW‚ü©
      exact this.2
    have hOopen : IsOpen O :=
      (hcurrOpen_open x.val).inter (isOpen_compl_iff.mpr isClosed_closure)
    have hOne : O.Nonempty := by
      simpa [Set.inter_comm] using
        hDense.inter_open_nonempty (currOpen x.val) (hcurrOpen_open x.val) (hcurrOpen_nonempty x.val)
    rcases exists_closedBall_subset (X := X) O hOopen hOne n with ‚ü®c, r, hrpos, hrle, hsub‚ü©
    let V : (closedBallFamily (X := X)).W := ‚ü®closedBall c r, ‚ü®c, r, hrpos, rfl‚ü©‚ü©
    have hExt : x.val ++ [V] ‚àà chainTree (closedBallFamily (X := X)).W := by
      by_cases hx0 : x.val = []
      ¬∑ simp [hx0, chainTree]
      ¬∑
        have hsubU : (V : Set X) ‚äÜ x.val.getLast hx0 := by
          have hsub' : (V : Set X) ‚äÜ currOpen x.val := by
            intro y hy; exact (hsub hy).1
          have hcurr :
              currOpen x.val = interior (x.val.getLast hx0 : Set X) := by
            simp [currOpen, List.getLast?_eq_getLast_of_ne_nil hx0]
          have hsub'' : (V : Set X) ‚äÜ interior (x.val.getLast hx0 : Set X) := by
            simpa [hcurr] using hsub'
          exact fun y hy => interior_subset (hsub'' hy)
        rw [concat_mem_chainTree (V := (closedBallFamily (X := X)).W)]
        refine ‚ü®x.prop, ?_‚ü©
        intro _; exact hsubU
    refine ‚ü®‚ü®V, hExt‚ü©, ?_‚ü©
    refine ‚ü®c, r, hrpos, rfl, hrle, ?_‚ü©
    change (closedBall c r ‚äÜ O)
    exact hsub
  let qS : QuasiStrategy (chainTree (closedBallFamily (X := X)).W) Player.zero := ‚ü®P, hPquasi‚ü©
  refine (GaleStewartGame.Game.existsWinning_iff_quasi
      (G := gameBM (X := X) (F := closedBallFamily (X := X)) A) (p := Player.zero)).2 ?_
  refine ‚ü®qS, ?_‚ü©
  intro a ha
  -- Regard the play as a branch of the underlying chain tree.
  have haCT : a ‚àà Descriptive.Tree.body (chainTree (closedBallFamily (X := X)).W) :=
    Descriptive.Tree.body_mono (PreStrategy.subtree_sub (S := qS.1)) ha
  -- consecutive moves are decreasing by inclusion
  have hstep : ‚àÄ i : ‚Ñï, (a.get (i + 1) : Set X) ‚äÜ (a.get i : Set X) := by
    intro i
    have htake : a.take (i + 2) ‚àà chainTree (closedBallFamily (X := X)).W :=
      Descriptive.Tree.take_mem_body haCT (i + 2)
    have hmem : a.take (i + 1) ++ [a.get (i + 1)] ‚àà chainTree (closedBallFamily (X := X)).W := by
      have hconcat : a.take (i + 1) ++ [a.get (i + 1)] = a.take (i + 2) := by
        simp
      simpa [hconcat] using htake
    have hsubset :=
      (concat_mem_chainTree (V := (closedBallFamily (X := X)).W)
        (x := a.take (i + 1)) (A := a.get (i + 1))).1 hmem
    have hne : a.take (i + 1) ‚â† [] := by
      have hlen : 0 < (a.take (i + 1)).length := by
        simp [Stream'.length_take]
      exact (List.length_pos_iff_ne_nil).1 hlen
    have hlast : (a.take (i + 1)).getLast hne = a.get i := by
      have hconcat : a.take i ++ [a.get i] = a.take (i + 1) := by
        simp
      simpa [hconcat] using (List.getLast_append_singleton (a := a.get i) (a.take i))
    have hsub : (a.get (i + 1) : Set X) ‚äÜ (a.take (i + 1)).getLast hne :=
      (hsubset.2 hne)
    simpa [hlast] using hsub
  have hmono : ‚àÄ {i j : ‚Ñï}, i ‚â§ j ‚Üí (a.get j : Set X) ‚äÜ (a.get i : Set X) := by
    intro i j hij
    induction hij with
    | refl => exact fun _ hx => hx
    | @step j _ ih => exact (hstep j).trans ih
  -- compatibility data for even moves
  have hEvenData :
      ‚àÄ n : ‚Ñï,
        ‚àÉ c r, 0 < r ‚àß (a.get (2 * n) : Set X) = closedBall c r ‚àß
          r ‚â§ (1 / (n + 1 : ‚Ñù)) ‚àß
          (a.get (2 * n) : Set X) ‚äÜ currOpen (a.take (2 * n)) ‚à© (closure (N n : Set X))·∂ú := by
    intro n
    have hprefix_mem : a.take (2 * n) ‚àà qS.1.subtree :=
      Descriptive.Tree.take_mem_body ha (2 * n)
    let preNode : qS.1.subtree := ‚ü®_, hprefix_mem‚ü©
    have hpos : IsPosition preNode.val Player.zero := by
      have : (2 * n) % 2 = 0 := by omega
      simp [IsPosition, Player.toNat, preNode, this]
    have hnext_mem : preNode.val ++ [a.get (2 * n)] ‚àà qS.1.subtree := by
      have ht : a.take (2 * n + 1) ‚àà qS.1.subtree :=
        Descriptive.Tree.take_mem_body ha (2 * n + 1)
      have htake' : a.take (2 * n + 1) = preNode.val ++ [a.get (2 * n)] := by
        simp [preNode, Nat.add_comm]
      simpa [htake'] using ht
    have hcompat :
        ‚ü®a.get (2 * n), by exact hnext_mem.1‚ü© ‚àà
          P ((PreStrategy.subtree_incl _ preNode)) (by simpa using hpos) := by
      exact P.subtree_compatible preNode (by simpa using hpos) hnext_mem
    simpa [P, preNode] using hcompat
  have hAvoid : ‚àÄ n : ‚Ñï, (a.get (2 * n) : Set X) ‚äÜ (closure (N n : Set X))·∂ú := by
    intro n
    rcases hEvenData n with ‚ü®_, _, _, _, _, hsub‚ü©
    intro x hx; exact (hsub hx).2
  have h0sub : (a.get 0 : Set X) ‚äÜ U0 := by
    rcases hEvenData 0 with ‚ü®_, _, _, _, _, hsub‚ü©
    intro x hx
    have : x ‚àà currOpen (a.take 0) := (hsub hx).1
    simpa [currOpen] using this
  have hEvenU0 : ‚àÄ n : ‚Ñï, (a.get (2 * n) : Set X) ‚äÜ U0 := by
    intro n
    exact (hmono (i := 0) (j := 2 * n) (by omega)).trans h0sub
  have hClosed : ‚àÄ n : ‚Ñï, IsClosed (a.get (2 * n) : Set X) := by
    intro n
    rcases (a.get (2 * n)).property with ‚ü®c, r, hr, hrball‚ü©
    simpa [hrball] using (isClosed_closedBall (x := c) (Œµ := r))
  have hBounded : ‚àÄ n : ‚Ñï, Bornology.IsBounded (a.get (2 * n) : Set X) := by
    intro n
    rcases (a.get (2 * n)).property with ‚ü®c, r, hr, hrball‚ü©
    simpa [hrball] using (isBounded_closedBall (x := c) (r := r))
  have hFiniteNonempty : ‚àÄ N : ‚Ñï, (‚ãÇ n ‚â§ N, (a.get (2 * n) : Set X)).Nonempty := by
    intro N
    rcases (a.get (2 * N)).property with ‚ü®c, r, hrpos, hrball‚ü©
    refine ‚ü®c, ?_‚ü©
    have hcN : c ‚àà (a.get (2 * N) : Set X) := by
      simpa [hrball, Metric.mem_closedBall, dist_self] using (le_of_lt hrpos)
    refine Set.mem_iInter‚ÇÇ.2 ?_
    intro n hn
    have hsub : (a.get (2 * N) : Set X) ‚äÜ (a.get (2 * n) : Set X) :=
      hmono (i := 2 * n) (j := 2 * N) (by omega)
    exact hsub hcN
  have hDiamTendsto :
      Filter.Tendsto (fun n : ‚Ñï => diam (a.get (2 * n) : Set X)) Filter.atTop (ùìù (0 : ‚Ñù)) := by
    have hDiamLe : ‚àÄ n : ‚Ñï, diam (a.get (2 * n) : Set X) ‚â§ 2 * (1 / (n + 1 : ‚Ñù)) := by
      intro n
      rcases hEvenData n with ‚ü®c, r, hrpos, hrball, hrle, _‚ü©
      have : diam (a.get (2 * n) : Set X) ‚â§ 2 * r := by
        simpa [hrball] using (diam_closedBall (x := c) (r := r) (le_of_lt hrpos))
      exact this.trans (by gcongr)
    have hlim : Filter.Tendsto (fun n : ‚Ñï => 2 * (1 / (n + 1 : ‚Ñù))) Filter.atTop (ùìù (0 : ‚Ñù)) := by
      simpa [mul_zero] using
        (tendsto_const_nhds.mul tendsto_one_div_add_atTop_nhds_zero_nat :
          Filter.Tendsto (fun n : ‚Ñï => (2 : ‚Ñù) * (1 / (n + 1 : ‚Ñù))) Filter.atTop (ùìù ((2 : ‚Ñù) * 0)))
    exact squeeze_zero (fun n => diam_nonneg) hDiamLe hlim
  obtain ‚ü®x0, hx0‚ü© :=
    nonempty_iInter_of_nonempty_biInter (fun n => hClosed n) (fun n => hBounded n)
      hFiniteNonempty hDiamTendsto
  have hxAll : x0 ‚àà ‚ãÇ i, (a.get i : Set X) := by
    refine Set.mem_iInter.2 ?_
    intro i
    rcases Nat.even_or_odd i with ‚ü®n, rfl‚ü© | ‚ü®n, rfl‚ü©
    ¬∑ simpa [two_mul] using (Set.mem_iInter.1 hx0 n)
    ¬∑
      have hxNext : x0 ‚àà (a.get (2 * (n + 1)) : Set X) := by
        simpa using (Set.mem_iInter.1 hx0 (n + 1))
      have hsub : (a.get (2 * (n + 1)) : Set X) ‚äÜ (a.get (2 * n + 1) : Set X) :=
        hmono (i := 2 * n + 1) (j := 2 * (n + 1)) (by omega)
      exact hsub hxNext
  have hxA : x0 ‚àà A := by
    have hxU0 : x0 ‚àà U0 := hEvenU0 0 (by simpa using (Set.mem_iInter.1 hx0 0))
    by_contra hxnot
    have hxUA : x0 ‚àà U0 \ A := ‚ü®hxU0, hxnot‚ü©
    have hxU : x0 ‚àà ‚ãÉ n, (N n : Set X) := by
      simpa [hUAeq] using hxUA
    rcases Set.mem_iUnion.1 hxU with ‚ü®n, hxn‚ü©
    have hxAvoid : x0 ‚àà (closure (N n : Set X))·∂ú :=
      hAvoid n (by simpa using (Set.mem_iInter.1 hx0 n))
    exact hxAvoid (subset_closure hxn)
  -- Conclude the payoff.
  have hxAll' : x0 ‚àà ‚ãÇ n, (a.get n : Set X) := by
    simpa [Set.mem_iInter] using hxAll
  refine ‚ü®‚ü®a, haCT‚ü©, ?_, rfl‚ü©
  change payoffHits (X := X) A (‚ãÇ n, (a.get n : Set X))
  exact ‚ü®x0, hxA, hxAll'‚ü©

theorem existsWinning_zero_of_residual_diff (A U0 : Set X) (hU0o : IsOpen U0)
    (hU0ne : U0.Nonempty) (hres : (U0 \ A)·∂ú ‚àà residual X) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  have hMeagre : IsMeagre (U0 \ A) := by
    simpa [IsMeagre] using hres
  exact existsWinning_zero_of_isMeagre_diff (A := A) (U0 := U0) hU0o hU0ne hMeagre

section UnconditionalLocalBasis

open Set

omit [CompleteSpace X] [Nonempty X] in
lemma denseWithin_trans {s t U0 : Set X} (hs : DenseWithin s U0) (ht : DenseWithin t s)
    (hsopen : IsOpen s) : DenseWithin t U0 := by
  intro O hOo hOsub hOne
  rcases hs O hOo hOsub hOne with ‚ü®x, hxO, hxs‚ü©
  have hO'open : IsOpen (O ‚à© s) := hOo.inter hsopen
  have hO'sub : O ‚à© s ‚äÜ s := by intro y hy; exact hy.2
  have hO'ne : (O ‚à© s).Nonempty := ‚ü®x, hxO, hxs‚ü©
  rcases ht (O ‚à© s) hO'open hO'sub hO'ne with ‚ü®y, hyO, hyt‚ü©
  exact ‚ü®y, hyO.1, hyt‚ü©

omit [Nonempty X] in
lemma denseWithin_iInter_of_isOpen_nat {U0 : Set X} (hU0o : IsOpen U0)
    {f : ‚Ñï ‚Üí Set X} (ho : ‚àÄ n, IsOpen (f n)) (hd : ‚àÄ n, DenseWithin (f n) U0) :
    DenseWithin (‚ãÇ n, f n) U0 := by
  let Y := {x // x ‚àà U0}
  letI : BaireSpace Y := (IsOpen.baireSpace (s := U0) hU0o)
  let g : ‚Ñï ‚Üí Set Y := fun n => {y | (y : X) ‚àà f n}
  have hgo : ‚àÄ n, IsOpen (g n) := by
    intro n
    simpa [g] using (ho n).preimage (continuous_subtype_val)
  have hgd : ‚àÄ n, Dense (g n) := by
    intro n
    refine dense_iff_inter_open.2 ?_
    intro O hOopen hOne
    rcases isOpen_induced_iff.mp hOopen with ‚ü®O', hO'open, rfl‚ü©
    rcases hOne with ‚ü®‚ü®x, hxU0‚ü©, hxO‚ü©
    have hxO' : x ‚àà O' := by simpa using hxO
    have hO1open : IsOpen (O' ‚à© U0) := hO'open.inter hU0o
    have hO1sub : O' ‚à© U0 ‚äÜ U0 := by intro y hy; exact hy.2
    have hO1ne : (O' ‚à© U0).Nonempty := ‚ü®x, hxO', hxU0‚ü©
    rcases hd n (O' ‚à© U0) hO1open hO1sub hO1ne with ‚ü®y, hyO1, hyf‚ü©
    refine ‚ü®‚ü®y, hyO1.2‚ü©, ?_‚ü©
    refine ‚ü®?_, ?_‚ü©
    ¬∑ exact hyO1.1
    ¬∑ exact hyf
  have hDenseInter : Dense (‚ãÇ n, g n) :=
    dense_iInter_of_isOpen_nat hgo hgd
  intro O hOo hOsub hOne
  have hO'open : IsOpen ((Subtype.val : Y ‚Üí X) ‚Åª¬π' O) :=
    hOo.preimage continuous_subtype_val
  have hO'ne : ((Subtype.val : Y ‚Üí X) ‚Åª¬π' O).Nonempty := by
    rcases hOne with ‚ü®x, hxO‚ü©
    exact ‚ü®‚ü®x, hOsub hxO‚ü©, hxO‚ü©
  have hInterNonempty :
      (((Subtype.val : Y ‚Üí X) ‚Åª¬π' O) ‚à© ‚ãÇ n, g n).Nonempty :=
    (dense_iff_inter_open.1 hDenseInter) _ hO'open hO'ne
  rcases hInterNonempty with ‚ü®‚ü®y, hyU0‚ü©, hyO, hyG‚ü©
  have hyf : y ‚àà ‚ãÇ n, f n := by
    refine Set.mem_iInter.2 ?_
    intro n
    have : (‚ü®y, hyU0‚ü© : Y) ‚àà g n := (Set.mem_iInter.1 hyG) n
    simpa [g] using this
  exact ‚ü®y, hyO, hyf‚ü©

lemma length_le_of_prefix {Œ± : Type*} {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ <+: l‚ÇÇ) :
    l‚ÇÅ.length ‚â§ l‚ÇÇ.length := by
  rcases h with ‚ü®t, rfl‚ü©
  simp

lemma getElem_eq_of_prefix {Œ± : Type*} {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ <+: l‚ÇÇ) :
    ‚àÄ i (hi : i < l‚ÇÅ.length),
      l‚ÇÅ[i]'hi = l‚ÇÇ[i]'(by exact lt_of_lt_of_le hi (length_le_of_prefix h)) := by
  induction l‚ÇÅ generalizing l‚ÇÇ with
  | nil =>
      intro i hi
      cases hi
  | cons a l‚ÇÅ ih =>
      cases l‚ÇÇ with
      | nil =>
          cases (List.prefix_nil.mp h)
      | cons b l‚ÇÇ =>
          rcases List.cons_prefix_cons.mp h with ‚ü®rfl, h'‚ü©
          intro i hi
          cases i with
          | zero =>
              simp
          | succ i =>
              have hi' : i < l‚ÇÅ.length := by
                simpa [List.length_cons] using hi
              have hget := ih (l‚ÇÇ := l‚ÇÇ) h' i hi'
              exact hget

theorem exists_open_nonempty_meagre_diff_of_existsWinning_zero_uncond
    (F : FamilyBM X) (hLB : F.LocalBasis) (A : Set X)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  have _ : Nonempty X := inferInstance
  rcases hWin with ‚ü®S, hSwin‚ü©
  have hroot : [] ‚àà chainTree F.W := nil_mem_chainTree (V := F.W)
  let root : Node (F := F) S := rootNode (F := F) (S := S) hroot
  let U0 : Set X := Node.openSet root
  have hU0o : IsOpen U0 := Node.openSet_isOpen root
  have hU0ne : U0.Nonempty := Node.openSet_nonempty root
  -- Levelwise disjoint refinements
  let Level : ‚Ñï ‚Üí Set (Node (F := F) S) :=
    Nat.rec ({root} : Set (Node (F := F) S))
      (fun n Leveln =>
        {y | ‚àÉ x ‚àà Leveln, ‚àÉ U ‚àà (childFamily_shrink (F := F) (S := S) x hLB n).1,
          y = childNode_shrink (F := F) (S := S) x hLB U n})
  have Level_zero : Level 0 = ({root} : Set (Node (F := F) S)) := rfl
  have Level_succ :
      ‚àÄ n, Level (n + 1) =
        {y | ‚àÉ x ‚àà Level n, ‚àÉ U ‚àà (childFamily_shrink (F := F) (S := S) x hLB n).1,
          y = childNode_shrink (F := F) (S := S) x hLB U n} := by
    intro n
    rfl
  let LevelOpen : ‚Ñï ‚Üí Set X := fun n => ‚ãÉ x ‚àà Level n, Node.openSet x
  have LevelOpen_open : ‚àÄ n, IsOpen (LevelOpen n) := by
    intro n
    refine isOpen_iUnion ?_
    intro x; refine isOpen_iUnion ?_
    intro hx; exact Node.openSet_isOpen x
  have LevelOpen_dense_succ : ‚àÄ n, DenseWithin (LevelOpen (n + 1)) (LevelOpen n) := by
    intro n O hOo hOsub hOne
    rcases hOne with ‚ü®z, hzO‚ü©
    have hzLevel : z ‚àà LevelOpen n := hOsub hzO
    rcases Set.mem_iUnion.mp hzLevel with ‚ü®x, hx‚ü©
    rcases Set.mem_iUnion.mp hx with ‚ü®hxLevel, hzIn‚ü©
    have hO'open : IsOpen (O ‚à© Node.openSet x) := hOo.inter (Node.openSet_isOpen x)
    have hO'ne : (O ‚à© Node.openSet x).Nonempty := ‚ü®z, hzO, hzIn‚ü©
    have hO'sub : O ‚à© Node.openSet x ‚äÜ Node.openSet x := by intro y hy; exact hy.2
    have hDense :=
      (childFamily_shrink (F := F) (S := S) x hLB n).2.2
    rcases hDense (O ‚à© Node.openSet x) hO'open hO'sub hO'ne with ‚ü®y, hyO', hyUnion‚ü©
    rcases Set.mem_iUnion.mp hyUnion with ‚ü®U, hU‚ü©
    rcases Set.mem_iUnion.mp hU with ‚ü®hUmem, hyIn‚ü©
    have hchild_mem : childNode_shrink (F := F) (S := S) x hLB U n ‚àà Level (n + 1) := by
      change (‚àÉ x' ‚àà Level n, ‚àÉ U' ‚àà (childFamily_shrink (F := F) (S := S) x' hLB n).1,
        childNode_shrink (F := F) (S := S) x hLB U n =
          childNode_shrink (F := F) (S := S) x' hLB U' n)
      exact ‚ü®x, hxLevel, U, hUmem, rfl‚ü©
    have hyOpen : y ‚àà Node.openSet (childNode_shrink (F := F) (S := S) x hLB U n) := by
      simpa [childNode_shrink_openSet] using hyIn
    refine ‚ü®y, hyO'.1, ?_‚ü©
    exact Set.mem_iUnion.mpr ‚ü®_, Set.mem_iUnion.mpr ‚ü®hchild_mem, hyOpen‚ü©‚ü©
  have LevelOpen_dense : ‚àÄ n, DenseWithin (LevelOpen n) U0 := by
    intro n
    induction' n with n ih
    ¬∑ intro O hOo hOsub hOne
      rcases hOne with ‚ü®x, hxO‚ü©
      have hLevel0 : LevelOpen 0 = U0 := by
        ext y
        constructor
        ¬∑ intro hy
          rcases Set.mem_iUnion.mp hy with ‚ü®x, hx‚ü©
          rcases Set.mem_iUnion.mp hx with ‚ü®hx0, hyx‚ü©
          have hx0' : x = root := by
            simpa [Level_zero] using hx0
          subst hx0'
          simpa [U0] using hyx
        ¬∑ intro hyU0
          refine Set.mem_iUnion.mpr ?_
          refine ‚ü®root, Set.mem_iUnion.mpr ?_‚ü©
          refine ‚ü®?_, ?_‚ü©
          ¬∑ simp [Level_zero]
          ¬∑ simpa [U0] using hyU0
      have hxLevel : x ‚àà LevelOpen 0 := by
        simpa [hLevel0] using (hOsub hxO)
      exact ‚ü®x, hxO, hxLevel‚ü©
    ¬∑ exact denseWithin_trans ih (LevelOpen_dense_succ n) (LevelOpen_open n)
  let G : Set X := ‚ãÇ n, LevelOpen n
  have hGdense : DenseWithin G U0 :=
    denseWithin_iInter_of_isOpen_nat (X := X) hU0o LevelOpen_open LevelOpen_dense
  have hGsubA : G ‚äÜ A := by
    intro y hyG
    have Level_disjoint :
        ‚àÄ n, (Level n).Pairwise (fun x y => Disjoint (Node.openSet x) (Node.openSet y)) := by
      intro n
      induction n with
      | zero =>
          intro x hx y hy hxy
          have hx' : x = root := by simpa [Level_zero] using hx
          have hy' : y = root := by simpa [Level_zero] using hy
          subst hx'
          subst hy'
          exact (hxy rfl).elim
      | succ n ih =>
          intro x hx y hy hxy
          rcases (by simpa [Level_succ] using hx) with ‚ü®x1, hx1, U1, hU1, rfl‚ü©
          rcases (by simpa [Level_succ] using hy) with ‚ü®x2, hx2, U2, hU2, rfl‚ü©
          by_cases hparent : x1 = x2
          ¬∑ subst hparent
            have hUneq : U1 ‚â† U2 := by
              intro hU
              apply hxy
              simp [hU]
            have hpair := (childFamily_shrink (F := F) (S := S) x1 hLB n).2.1
            have hdisj := hpair hU1 hU2 hUneq
            simpa [childNode_shrink_openSet] using hdisj
          ¬∑
            have hdisj_par := ih hx1 hx2 hparent
            have hsub1 :
                Node.openSet (childNode_shrink (F := F) (S := S) x1 hLB U1 n) ‚äÜ
                  Node.openSet x1 :=
              childNode_shrink_openSet_subset (F := F) (S := S) (x := x1) (hLB := hLB)
                (U := U1) (n := n)
            have hsub2 :
                Node.openSet (childNode_shrink (F := F) (S := S) x2 hLB U2 n) ‚äÜ
                  Node.openSet x2 :=
              childNode_shrink_openSet_subset (F := F) (S := S) (x := x2) (hLB := hLB)
                (U := U2) (n := n)
            exact Disjoint.mono hsub1 hsub2 hdisj_par
    have Level_unique :
        ‚àÄ n {x1 x2}, x1 ‚àà Level n ‚Üí x2 ‚àà Level n ‚Üí
          y ‚àà Node.openSet x1 ‚Üí y ‚àà Node.openSet x2 ‚Üí x1 = x2 := by
      intro n x1 x2 hx1 hx2 hy1 hy2
      by_contra hxy
      have hdisj := Level_disjoint n hx1 hx2 hxy
      exact (Set.disjoint_left.1 hdisj) hy1 hy2
    have hNode_exists : ‚àÄ n, ‚àÉ x, x ‚àà Level n ‚àß y ‚àà Node.openSet x := by
      intro n
      have hyL : y ‚àà LevelOpen n := (Set.mem_iInter.mp hyG) n
      rcases Set.mem_iUnion.mp hyL with ‚ü®x, hx‚ü©
      rcases Set.mem_iUnion.mp hx with ‚ü®hxLevel, hyIn‚ü©
      exact ‚ü®x, hxLevel, hyIn‚ü©
    classical
    choose xnode hxnodeLevel hyxnode using hNode_exists
    have hx0 : xnode 0 = root := by
      have hx0' : xnode 0 ‚àà Level 0 := hxnodeLevel 0
      simpa [Level_zero] using hx0'
    have xnode_parent :
        ‚àÄ n, ‚àÉ U ‚àà (childFamily_shrink (F := F) (S := S) (xnode n) hLB n).1,
          xnode (n + 1) =
            childNode_shrink (F := F) (S := S) (xnode n) hLB U n := by
      intro n
      have hx' : xnode (n + 1) ‚àà Level (n + 1) := hxnodeLevel (n + 1)
      rcases (by simpa [Level_succ] using hx') with ‚ü®x', hx'Level, U, hU, hxnode‚ü©
      have hyParent : y ‚àà Node.openSet x' := by
        have hyChild :
            y ‚àà Node.openSet (childNode_shrink (F := F) (S := S) x' hLB U n) := by
          simpa [hxnode] using hyxnode (n + 1)
        have hsub :=
          childNode_shrink_openSet_subset (F := F) (S := S) (x := x') (hLB := hLB) (U := U)
            (n := n)
        exact hsub hyChild
      have hxuniq : xnode n = x' := by
        refine Level_unique (n := n) (x1 := xnode n) (x2 := x') (hxnodeLevel n) hx'Level ?_ ?_
        ¬∑ exact hyxnode n
        ¬∑ exact hyParent
      subst hxuniq
      refine ‚ü®U, hU, ?_‚ü©
      simpa using hxnode
    choose U hUmem hxnode_child using xnode_parent
    have hist_prefix_succ : ‚àÄ n, (xnode n).hist <+: (xnode (n + 1)).hist := by
      intro n
      simp [hxnode_child n, childNode_shrink, childNode, List.append_assoc]
    have hist_prefix_le : ‚àÄ {i j}, i ‚â§ j ‚Üí (xnode i).hist <+: (xnode j).hist := by
      intro i j hij
      rcases Nat.exists_eq_add_of_le hij with ‚ü®k, rfl‚ü©
      clear hij
      induction k with
      | zero =>
          simp
      | succ k ih =>
          exact List.IsPrefix.trans ih (hist_prefix_succ (i + k))
    have hist_len_succ : ‚àÄ n, (xnode (n + 1)).hist.length = (xnode n).hist.length + 2 := by
      intro n
      simp [hxnode_child n, childNode_shrink, childNode, List.length_append]
    have hist_len : ‚àÄ n, (xnode n).hist.length = 2 * n + 1 := by
      intro n
      induction n with
      | zero =>
          have hrootlen : root.hist.length = 1 := by
            simp [root, rootNode]
          simpa [hx0] using hrootlen
      | succ n ih =>
          have hlen := hist_len_succ n
          have := ih
          omega
    let a : Stream' F.W := fun n =>
      (xnode (n + 1)).hist.get ‚ü®n, by
        have hlen := hist_len (n + 1)
        have : n < 2 * (n + 1) + 1 := by omega
        simpa [hlen] using this‚ü©
    have ha_take_full : ‚àÄ n, a.take (2 * n + 1) = (xnode n).hist := by
      intro n
      apply List.ext_getElem
      ¬∑ have hlen := hist_len n
        simp [Stream'.length_take, hlen]
      ¬∑ intro i hi hi2
        have hi1 : i < (xnode (i + 1)).hist.length := by
          have hlen := hist_len (i + 1)
          have : i < 2 * (i + 1) + 1 := by omega
          simpa [hlen] using this
        have hdef : a.get i = (xnode (i + 1)).hist[i]'hi1 := by
          -- proof-irrelevant index in `a`'s definition
          simp [Stream'.get, a]
        have hgoal : a.get i = (xnode n).hist[i]'hi2 := by
          by_cases hle : i + 1 ‚â§ n
          ¬∑ have hprefix := hist_prefix_le (i := i + 1) (j := n) hle
            have hget :=
              getElem_eq_of_prefix (l‚ÇÅ := (xnode (i + 1)).hist) (l‚ÇÇ := (xnode n).hist) hprefix i hi1
            have hget' : (xnode (i + 1)).hist[i]'hi1 = (xnode n).hist[i]'hi2 := by
              simpa using hget
            exact hdef.trans hget'
          ¬∑ have hge : n ‚â§ i + 1 := Nat.le_of_not_ge hle
            have hprefix := hist_prefix_le (i := n) (j := i + 1) hge
            have hget :=
              getElem_eq_of_prefix (l‚ÇÅ := (xnode n).hist) (l‚ÇÇ := (xnode (i + 1)).hist) hprefix i hi2
            have hget' : (xnode (i + 1)).hist[i]'hi1 = (xnode n).hist[i]'hi2 := by
              simpa using hget.symm
            exact hdef.trans hget'
        simpa [Stream'.take_get] using hgoal
    have ha_take_mem : ‚àÄ n, a.take n ‚àà S.pre.subtree := by
      intro n
      have hfull := ha_take_full n
      have hn : n ‚â§ 2 * n + 1 := by omega
      have hshort : a.take n = (xnode n).hist.take n := by
        have := congrArg (fun l => l.take n) hfull
        simpa [List.take_take, Nat.min_eq_right hn] using this
      have hprefix : a.take n <+: (xnode n).hist := by
        have h := (List.take_prefix n (xnode n).hist)
        simpa [hshort] using h
      exact Descriptive.Tree.mem_of_prefix hprefix (xnode n).mem
    have ha_body : a ‚àà Descriptive.Tree.body S.pre.subtree := by
      refine Descriptive.Tree.mem_body_of_take (m := 0) (T := S.pre.subtree) (x := a) ?_
      intro n hn
      simpa using ha_take_mem n
    let aBody : Descriptive.Tree.body S.pre.subtree := ‚ü®a, ha_body‚ü©
    rcases hSwin aBody.prop with ‚ü®ha_tree, hpay‚ü©
    have hpay' : (A ‚à© ‚ãÇ n, (aBody.val.get n : Set X)).Nonempty := by
      have hpay0 :
          (A ‚à© ‚ãÇ n, ((ha_tree : Descriptive.Tree.body (chainTree F.W)).val.get n : Set X)).Nonempty := by
        simpa [gameBM, interGame, payoffHits, Player.payoff] using hpay.1
      simpa [hpay.2] using hpay0
    rcases hpay' with ‚ü®z, hzA, hzI‚ü©
    have hsubset : (‚ãÇ n, (aBody.val.get n : Set X)) ‚äÜ {y} := by
      intro z hz
      have hz_even : ‚àÄ n, z ‚àà (aBody.val.get (2 * (n + 1)) : Set X) := by
        intro n
        have := (Set.mem_iInter.mp hz) (2 * (n + 1))
        simpa using this
      have hy_even : ‚àÄ n, y ‚àà (aBody.val.get (2 * (n + 1)) : Set X) := by
        intro n
        have hyopen : y ‚àà Node.openSet (xnode (n + 1)) := hyxnode (n + 1)
        have hyLast :
            y ‚àà ((xnode (n + 1)).hist.getLast (Node.ne_nil (xnode (n + 1))) : Set X) :=
          (Node.openSet_subset_last (xnode (n + 1))) hyopen
        have hlen' := hist_len (n + 1)
        have hi : 2 * (n + 1) < (xnode (n + 1)).hist.length := by
          simp [hlen']
        have haP :
            aBody.val ‚àà Stream'.Discrete.principalOpen (xnode (n + 1)).hist := by
          apply (Stream'.Discrete.principalOpen_iff_restrict
            (a := aBody.val) (x := (xnode (n + 1)).hist)).2
          have := ha_take_full (n + 1)
          simpa [hlen'] using this.symm
        have hidx := (Stream'.Discrete.principalOpen_index (a := aBody.val)
          (x := (xnode (n + 1)).hist)).1 haP
        have hget :
            aBody.val.get (2 * (n + 1)) =
              (xnode (n + 1)).hist[2 * (n + 1)]'hi := by
          exact hidx _ hi
        have hlast :
            (xnode (n + 1)).hist.getLast (Node.ne_nil (xnode (n + 1))) =
              (xnode (n + 1)).hist[2 * (n + 1)]'hi := by
          simp [List.getLast_eq_getElem, hlen']
        simpa [hget, hlast] using hyLast
      have hdist0 : dist z y = 0 := by
        by_contra hne
        have hpos : 0 < dist z y := lt_of_le_of_ne dist_nonneg (Ne.symm hne)
        have hpos' : 0 < dist z y / 2 := by nlinarith
        rcases exists_nat_one_div_lt hpos' with ‚ü®N, hN‚ü©
        rcases nextMove_shrink_subset_ball (F := F) (S := S) (x := xnode N) (hLB := hLB)
          (U := U N) (n := N) with ‚ü®c, r, hrpos, hrlt, hsub‚ü©
        have hlastmove :
            (aBody.val.get (2 * (N + 1)) : Set X) =
              (nextMove_shrink (F := F) (S := S) (xnode N) hLB (U N) N : Set X) := by
          have hlen' := hist_len (N + 1)
          have hi : 2 * (N + 1) < (xnode (N + 1)).hist.length := by
            simp [hlen']
          have haP :
              aBody.val ‚àà Stream'.Discrete.principalOpen (xnode (N + 1)).hist := by
            apply (Stream'.Discrete.principalOpen_iff_restrict
              (a := aBody.val) (x := (xnode (N + 1)).hist)).2
            have := ha_take_full (N + 1)
            simpa [hlen'] using this.symm
          have hidx := (Stream'.Discrete.principalOpen_index (a := aBody.val)
            (x := (xnode (N + 1)).hist)).1 haP
          have hget :
              aBody.val.get (2 * (N + 1)) =
                (xnode (N + 1)).hist[2 * (N + 1)]'hi := by
            exact hidx _ hi
          have hlast :
              (xnode (N + 1)).hist.getLast (Node.ne_nil (xnode (N + 1))) =
                (xnode (N + 1)).hist[2 * (N + 1)]'hi := by
            simp [List.getLast_eq_getElem, hlen']
          have hlast' :
              (xnode (N + 1)).hist.getLast (Node.ne_nil (xnode (N + 1))) =
                (nextMove_shrink (F := F) (S := S) (xnode N) hLB (U N) N : Set X) := by
            simp [hxnode_child N, childNode_shrink, childNode, nextMove_shrink, nextMove,
              List.append_assoc]
          calc
            (aBody.val.get (2 * (N + 1)) : Set X) =
                ((xnode (N + 1)).hist[2 * (N + 1)] : Set X) := by
                  simpa using congrArg (fun t : F.W => (t : Set X)) hget
            _ = (xnode (N + 1)).hist.getLast (Node.ne_nil (xnode (N + 1))) := by
                  simp [hlast]
            _ = (nextMove_shrink (F := F) (S := S) (xnode N) hLB (U N) N : Set X) := hlast'
        have hzball : z ‚àà Metric.ball c r := by
          have hz' : z ‚àà (aBody.val.get (2 * (N + 1)) : Set X) := hz_even N
          have : z ‚àà (nextMove_shrink (F := F) (S := S) (xnode N) hLB (U N) N : Set X) := by
            simpa [hlastmove] using hz'
          exact hsub this
        have hyball : y ‚àà Metric.ball c r := by
          have hy' : y ‚àà (aBody.val.get (2 * (N + 1)) : Set X) := hy_even N
          have : y ‚àà (nextMove_shrink (F := F) (S := S) (xnode N) hLB (U N) N : Set X) := by
            simpa [hlastmove] using hy'
          exact hsub this
        have hdist_le : dist z y ‚â§ 2 * r := by
          have hzle : dist z c ‚â§ r := by
            have : dist z c < r := by simpa [Metric.mem_ball] using hzball
            exact le_of_lt this
          have hyle : dist y c ‚â§ r := by
            have : dist y c < r := by simpa [Metric.mem_ball] using hyball
            exact le_of_lt this
          have htri : dist z y ‚â§ dist z c + dist c y := dist_triangle z c y
          have htri' : dist z y ‚â§ dist z c + dist y c := by simpa [dist_comm] using htri
          linarith
        have hlt : 2 * r < dist z y := by
          have hN' : shrinkRadius (n := N) < dist z y / 2 := by
            simpa [shrinkRadius] using hN
          have h1 : 2 * r < 2 * shrinkRadius (n := N) := by
            have hpos : 0 < (2 : ‚Ñù) := by norm_num
            exact (mul_lt_mul_of_pos_left hrlt hpos)
          have h2 : 2 * shrinkRadius (n := N) < dist z y := by
            have hpos : 0 < (2 : ‚Ñù) := by norm_num
            have hmul := (mul_lt_mul_of_pos_left hN' hpos)
            have h2' : 2 * (dist z y / 2) = dist z y := by nlinarith
            simpa [h2'] using hmul
          exact lt_trans h1 h2
        have hcontr : dist z y < dist z y := lt_of_le_of_lt hdist_le hlt
        exact (lt_irrefl _ hcontr)
      have hzEq : z = y := dist_eq_zero.mp hdist0
      simp [Set.mem_singleton_iff, hzEq]
    have hz_in : z ‚àà {y} := hsubset hzI
    have hzEq : z = y := by simpa [Set.mem_singleton_iff] using hz_in
    simpa [hzEq] using hzA
  -- G is a dense GŒ¥ in the open subspace U0, hence U0 \ A is meagre
  let Gsub : Set {x // x ‚àà U0} := {y | (y : X) ‚àà G}
  letI : BaireSpace {x // x ‚àà U0} := (IsOpen.baireSpace (s := U0) hU0o)
  have hGsub_GŒ¥ : IsGŒ¥ Gsub := by
    refine (isGŒ¥_iff_eq_iInter_nat).2 ?_
    refine ‚ü®fun n => {y : {x // x ‚àà U0} | (y : X) ‚àà LevelOpen n}, ?_, ?_‚ü©
    ¬∑ intro n
      simpa using (LevelOpen_open n).preimage (continuous_subtype_val)
    ¬∑ ext y; simp [G, Gsub, LevelOpen]
  have hGsub_dense : Dense Gsub := by
    refine dense_iff_inter_open.2 ?_
    intro O hOo hOne
    rcases isOpen_induced_iff.mp hOo with ‚ü®O', hO'open, rfl‚ü©
    rcases hOne with ‚ü®‚ü®x, hxU0‚ü©, hxO‚ü©
    have hxO' : x ‚àà O' := by simpa using hxO
    have hO1open : IsOpen (O' ‚à© U0) := hO'open.inter hU0o
    have hO1sub : O' ‚à© U0 ‚äÜ U0 := by intro y hy; exact hy.2
    have hO1ne : (O' ‚à© U0).Nonempty := ‚ü®x, hxO', hxU0‚ü©
    rcases hGdense (O' ‚à© U0) hO1open hO1sub hO1ne with ‚ü®y, hyO1, hyG‚ü©
    refine ‚ü®‚ü®y, hyO1.2‚ü©, ?_‚ü©
    refine ‚ü®?_, ?_‚ü©
    ¬∑ exact hyO1.1
    ¬∑ exact hyG
  have hres : Gsub ‚àà residual {x // x ‚àà U0} :=
    (mem_residual (X := {x // x ‚àà U0})).2 ‚ü®Gsub, subset_rfl, hGsub_GŒ¥, hGsub_dense‚ü©
  let m : Set {x // x ‚àà U0} := {x | (x : X) ‚àà U0 \ A}
  have hmeagre_sub : IsMeagre (m : Set {x // x ‚àà U0}) := by
    have : m·∂ú ‚àà residual {x // x ‚àà U0} := by
      have hsub : Gsub ‚äÜ m·∂ú := by
        intro y hy
        have hy' : (y : X) ‚àà G := hy
        have hyA : (y : X) ‚àà A := hGsubA hy'
        have hyU0 : (y : X) ‚àà U0 := y.property
        simp [m, Set.mem_diff, hyA]
      exact Filter.mem_of_superset hres hsub
    simpa [IsMeagre] using this
  have hmeagre : IsMeagre (U0 \ A) := by
    have hmeagre' :
        IsMeagre ((m : Set {x // x ‚àà U0}) : Set X) :=
      IsMeagre.image_val (s := U0) (m := m) hmeagre_sub
    have hco :
        ((m : Set {x // x ‚àà U0}) : Set X) = U0 \ A := by
      ext x
      constructor
      ¬∑ intro hx
        rcases hx with ‚ü®y, hy, rfl‚ü©
        exact hy
      ¬∑ intro hx
        exact ‚ü®‚ü®x, hx.1‚ü©, hx, rfl‚ü©
    simpa [hco] using hmeagre'
  exact ‚ü®U0, hU0o, hU0ne, hmeagre‚ü©

theorem basis_invariant_zero_of_existsWinning_uncond
    (F : FamilyBM X) (hLB : F.LocalBasis) (A : Set X)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  obtain ‚ü®U0, hU0o, hU0ne, hMeagre‚ü© :=
    exists_open_nonempty_meagre_diff_of_existsWinning_zero_uncond
      (X := X) (F := F) (hLB := hLB) (A := A) hWin
  exact existsWinning_zero_of_isMeagre_diff (X := X) (A := A) (U0 := U0) hU0o hU0ne hMeagre

end UnconditionalLocalBasis

/-!
### Baire‚Äëproperty corollaries

The following lemmas use `BaireMeasurableSet A` to upgrade the weak
‚Äúnon‚Äëmeagre‚Äù conclusion into a *comeagre‚Äëon‚Äësome‚Äëopen* statement. This is
standard in the classical Banach‚ÄìMazur theory, but **not** minimal for the
one‚Äëway implications proved above.
-/

omit [CompleteSpace X] [Nonempty X] in
theorem exists_open_nonempty_meagre_diff_of_not_isMeagre_baire (A : Set X)
    (hA : BaireMeasurableSet A) (hnot : ¬¨ IsMeagre A) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  let U : TopologicalSpace.Opens X := dom (A := A)
  have hres : A =·µá (U : Set X) := residual.dom.eq_residual (A := A) hA
  have hdiff : IsMeagre ((U : Set X) \ A) := by
    have h := (Filter.eventuallyEq_set' (l := residual X) (s := A) (t := (U : Set X))).1 hres
    simpa [IsMeagre] using h.2
  have hU_nonempty : (U : Set X).Nonempty := by
    by_contra hUempty
    have hUeq : (U : Set X) = ‚àÖ := (Set.not_nonempty_iff_eq_empty).1 hUempty
    have hAmeagre : IsMeagre A := by
      have h := (Filter.eventuallyEq_set' (l := residual X) (s := A) (t := (U : Set X))).1 hres
      have hAU : IsMeagre (A \ (U : Set X)) := by
        simpa [IsMeagre] using h.1
      simpa [hUeq] using hAU
    exact hnot hAmeagre
  exact ‚ü®(U : Set X), U.isOpen, hU_nonempty, hdiff‚ü©

omit [CompleteSpace X] [Nonempty X] in
theorem exists_open_nonempty_meagre_diff_of_existsWinning_zero_baire (F : FamilyBM X) (A : Set X)
    (hA : BaireMeasurableSet A)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  have hnot : ¬¨ IsMeagre A :=
    existsWinning_zero_imp_not_isMeagre (F := F) (A := A) hWin
  exact exists_open_nonempty_meagre_diff_of_not_isMeagre_baire (X := X) (A := A) hA hnot

theorem existsWinning_zero_of_not_isMeagre_baire (A : Set X) (hA : BaireMeasurableSet A)
    (hnot : ¬¨ IsMeagre A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  obtain ‚ü®U0, hU0o, hU0ne, hMeagre‚ü© :=
    exists_open_nonempty_meagre_diff_of_not_isMeagre_baire (X := X) (A := A) hA hnot
  exact existsWinning_zero_of_isMeagre_diff (A := A) (U0 := U0) hU0o hU0ne hMeagre

theorem basis_invariant_zero_of_existsWinning_baire (F : FamilyBM X) (A : Set X)
    (hA : BaireMeasurableSet A)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  obtain ‚ü®U0, hU0o, hU0ne, hMeagre‚ü© :=
    exists_open_nonempty_meagre_diff_of_existsWinning_zero_baire (X := X) (F := F) (A := A) hA hWin
  exact existsWinning_zero_of_isMeagre_diff (A := A) (U0 := U0) hU0o hU0ne hMeagre

theorem existsWinning_one_iff_isMeagre_closedBall_baire (A : Set X) (hA : BaireMeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.one ‚Üî
      IsMeagre A := by
  constructor
  ¬∑ intro hWin
    by_contra hAmeagre
    have hzero : (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero :=
      existsWinning_zero_of_not_isMeagre_baire (X := X) (A := A) hA hAmeagre
    have hne : [] ‚àà (gameBM (X := X) (F := closedBallFamily (X := X)) A).tree := by
      simpa [gameBM, interGame] using
        (nil_mem_chainTree (V := (closedBallFamily (X := X)).W))
    exact (GaleStewartGame.Game.ExistsWinning.not_both_winning
      (G := gameBM (X := X) (F := closedBallFamily (X := X)) A) (p := Player.one) hWin hne) hzero
  ¬∑ intro hMeagre
    exact existsWinning_one_of_isMeagre_BM (F := closedBallFamily (X := X)) (A := A) hMeagre

theorem existsWinning_zero_iff_comeagre_closedBall_baire (A : Set X) (hA : BaireMeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  constructor
  ¬∑ intro hWin
    have hnot : ¬¨ IsMeagre A := by
      intro hMeagre
      have hOne : (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.one :=
        existsWinning_one_of_isMeagre_BM (F := closedBallFamily (X := X)) (A := A) hMeagre
      have hne : [] ‚àà (gameBM (X := X) (F := closedBallFamily (X := X)) A).tree := by
        simpa [gameBM, interGame] using
          (nil_mem_chainTree (V := (closedBallFamily (X := X)).W))
      exact (GaleStewartGame.Game.ExistsWinning.not_both_winning
        (G := gameBM (X := X) (F := closedBallFamily (X := X)) A) (p := Player.zero) hWin hne) hOne
    exact exists_open_nonempty_meagre_diff_of_not_isMeagre_baire (X := X) (A := A) hA hnot
  ¬∑ rintro ‚ü®U0, hU0o, hU0ne, hMeagre‚ü©
    exact existsWinning_zero_of_isMeagre_diff (A := A) (U0 := U0) hU0o hU0ne hMeagre

theorem basis_invariant_zero_closedBall_baire (A : Set X) (hA : BaireMeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) :=
  existsWinning_zero_iff_comeagre_closedBall_baire (X := X) (A := A) hA

/-!
### Borel corollaries (Polish-friendly)

In Polish spaces, Borel sets are Baire-measurable, so the preceding lemmas apply
without mentioning `BaireMeasurableSet` explicitly. We record the convenient
corollaries for `MeasurableSet`.
-/

section Borel

variable [MeasurableSpace X] [BorelSpace X]

omit [CompleteSpace X] [Nonempty X] in
theorem exists_open_nonempty_meagre_diff_of_not_isMeagre_borel (A : Set X)
    (hA : MeasurableSet A) (hnot : ¬¨ IsMeagre A) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  exact exists_open_nonempty_meagre_diff_of_not_isMeagre_baire (X := X) (A := A)
    (hA.baireMeasurableSet) hnot

omit [CompleteSpace X] [Nonempty X] in
theorem exists_open_nonempty_meagre_diff_of_existsWinning_zero_borel (F : FamilyBM X) (A : Set X)
    (hA : MeasurableSet A)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  exact exists_open_nonempty_meagre_diff_of_existsWinning_zero_baire (X := X) (F := F) (A := A)
    (hA.baireMeasurableSet) hWin

theorem existsWinning_zero_of_not_isMeagre_borel (A : Set X) (hA : MeasurableSet A)
    (hnot : ¬¨ IsMeagre A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  exact existsWinning_zero_of_not_isMeagre_baire (X := X) (A := A) (hA.baireMeasurableSet) hnot

theorem basis_invariant_zero_of_existsWinning_borel (F : FamilyBM X) (A : Set X)
    (hA : MeasurableSet A)
    (hWin : (gameBM (X := X) (F := F) A).ExistsWinning Player.zero) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero := by
  exact basis_invariant_zero_of_existsWinning_baire (X := X) (F := F) (A := A)
    (hA.baireMeasurableSet) hWin

theorem existsWinning_one_iff_isMeagre_closedBall_borel (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.one ‚Üî
      IsMeagre A := by
  exact existsWinning_one_iff_isMeagre_closedBall_baire (X := X) (A := A) (hA.baireMeasurableSet)

theorem existsWinning_zero_iff_comeagre_closedBall_borel (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  exact existsWinning_zero_iff_comeagre_closedBall_baire (X := X) (A := A) (hA.baireMeasurableSet)

theorem basis_invariant_zero_closedBall_borel (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) :=
  existsWinning_zero_iff_comeagre_closedBall_borel (X := X) (A := A) hA

end Borel

end CompleteMetric

section Polish

open Topology Metric

variable {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X]
variable [MeasurableSpace X] [BorelSpace X]
variable [SecondCountableTopology X]

/-!
### Polish-space Banach‚ÄìMazur (Borel payoff sets)

In Polish spaces, Borel sets are Baire-measurable, so the standard
Banach‚ÄìMazur characterizations can be stated with `MeasurableSet` alone.
These are restatements of the `Borel` corollaries from the complete-metric
section, but packaged for the Polish setting.
-/

omit [CompleteSpace X] [SecondCountableTopology X] in
theorem exists_open_nonempty_meagre_diff_of_existsWinning_zero_polish (A : Set X)
    (hA : MeasurableSet A)
    (hWin : (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero) :
    ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  exact exists_open_nonempty_meagre_diff_of_existsWinning_zero_borel
    (X := X) (F := closedBallFamily (X := X)) (A := A) hA hWin

omit [SecondCountableTopology X] in
theorem existsWinning_zero_iff_comeagre_closedBall_polish (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) := by
  exact existsWinning_zero_iff_comeagre_closedBall_borel (X := X) (A := A) hA

omit [SecondCountableTopology X] in
theorem existsWinning_one_iff_isMeagre_closedBall_polish (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.one ‚Üî
      IsMeagre A := by
  exact existsWinning_one_iff_isMeagre_closedBall_borel (X := X) (A := A) hA

omit [SecondCountableTopology X] in
theorem basis_invariant_zero_closedBall_polish (A : Set X) (hA : MeasurableSet A) :
    (gameBM (X := X) (F := closedBallFamily (X := X)) A).ExistsWinning Player.zero ‚Üî
      ‚àÉ U0, IsOpen U0 ‚àß U0.Nonempty ‚àß IsMeagre (U0 \ A) :=
  existsWinning_zero_iff_comeagre_closedBall_polish (X := X) (A := A) hA

/-!
### Unconditional Banach‚ÄìMazur direction (no measurability)

The next results (to be completed) will show that a winning strategy for
`Player.zero` yields a dense `GŒ¥` subset of `A`, hence `A` is comeagre on
some nonempty open set. The proof follows the classical Oxtoby‚ÄìTelg√°rsky
construction using disjoint refinements inside open sets and the Baire
category theorem for complete metric spaces.
-/

-- (Unconditional section to be completed.)

end Polish

end BanachMazur

namespace Choquet

open Topology

variable (X : Type*) [TopologicalSpace X] [Nonempty X]

/-- The (weak) Banach‚ÄìMazur game `BM(X)`: players choose nonempty open sets decreasing by inclusion;
Player `one` wins iff the intersection is nonempty. -/
def BMGame : Game {U : Set X | IsOpen U ‚àß U.Nonempty} :=
  interGame (X := X)
    (V := {U : Set X | IsOpen U ‚àß U.Nonempty})
    (PO := {s | s.Nonempty})

/-- A space is *weakly Œ±-favorable* if Player `one` has a winning strategy in `BMGame`. -/
def IsWeaklyAlphaFavorable : Prop :=
  (BMGame X).ExistsWinning Player.one

lemma BMGame_eq_gameBM_univ :
    BMGame X = BanachMazur.gameBM (X := X) (F := BanachMazur.openFamilyBM (X := X)) Set.univ := by
  ext s <;> simp [BMGame, BanachMazur.gameBM, BanachMazur.openFamilyBM, BanachMazur.payoffHits]

lemma IsWeaklyAlphaFavorable_iff :
    IsWeaklyAlphaFavorable X ‚Üî
      (BanachMazur.gameBM (X := X) (F := BanachMazur.openFamilyBM (X := X)) Set.univ).ExistsWinning Player.one := by
  simp [IsWeaklyAlphaFavorable, BMGame_eq_gameBM_univ]

end Choquet
